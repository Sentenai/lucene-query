-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient conversion of values into readable byte strings.
--   
--   Efficient conversion of values into readable byte strings.
@package bytestring-show
@version 0.3.5.6


-- | Efficiently convert from values to lazy byte strings.
module Text.Show.ByteString

-- | Conversion of values to readable byte strings. Minimal complete
--   definition: <a>showp</a> or <a>showpPrec</a>
class Show a where showpPrec _ = showp showp = showpPrec 0 showpList [] = putWord8 91 >> putWord8 93 showpList (x : xs) = putWord8 91 >> showp x >> go xs where go (y : ys) = putWord8 44 >> showp y >> go ys go [] = putWord8 93

-- | Encodes a value to an efficient byte string builder. The precedence is
--   used to determine where to put parentheses in a shown expression
--   involving operators.
--   
--   Values of type Put can be efficiently combined, so the showp functions
--   are available for showing multiple values before producing an output
--   byte string.
showpPrec :: Show a => Int -> a -> Put

-- | Encodes a value to an efficient byte string builder. Values of type
--   Put can be efficiently combined, so this is available for building
--   strings from multiple values.
showp :: Show a => a -> Put

-- | Allows for specialized display of lists of values. This is used, for
--   example, when showing arrays of Chars.
showpList :: Show a => [a] -> Put

-- | Encode a single value into a byte string
show :: Show a => a -> ByteString

-- | Writes a single Char to a byte string, assuming it's ascii.
putAscii :: Char -> Put

-- | Writes a single Char to a byte string, properly UTF-8 encoded
putUTF8 :: Char -> Put

-- | Writes a string of ascii characters to a byte string
putAsciiStr :: String -> Put

-- | Writes a string of unicode characters to a byte string, properly UTF-8
--   encoded
putUTF8Str :: String -> Put

-- | Puts the decimal digit corresponding to the given Int without checking
--   that it is in the interval [0,9]
unsafePutDigit :: Int -> Put

-- | Puts the digit corresponding to the Int passed in.
putDigit :: Int -> Put

-- | Shows an Integral number using the base specified by the first
--   argument and the chracter representation specified by the second.
showpIntAtBase :: Integral a => a -> (Int -> Char) -> a -> Put

-- | Show a signed RealFloat value using decimal notation when the absolute
--   value lies between 0.1 and 9,999,999, and scientific notation
--   otherwise. The optional integer can be used to specify precision.
showpGFloat :: RealFloat a => Maybe Int -> a -> Put

-- | Show a signed RealFloat value using decimal notation. The optional
--   integer can be used to specify precision.
showpFFloat :: RealFloat a => Maybe Int -> a -> Put

-- | Show a signed RealFloat value using scientific (exponential) notation.
--   The optional integer can be used to specify precision.
showpEFloat :: RealFloat a => Maybe Int -> a -> Put

-- | Merge several string builders, separating them by newlines
unlinesP :: [Put] -> Put

-- | Merge several string builders, separating them by spaces
unwordsP :: [Put] -> Put

-- | A utility function for surrounding output by parentheses
--   conditionally.
showpParen :: Bool -> Put -> Put

-- | Print a value to the standard output
print :: Show a => a -> IO ()

-- | Put merely lifts Builder into a Writer monad, applied to ().
type Put = PutM ()

-- | The PutM type. A Writer monad over the efficient Builder monoid.
newtype PutM a :: * -> *
Put :: PairS a -> PutM a
[unPut] :: PutM a -> PairS a

-- | Run the <a>Put</a> monad with a serialiser
runPut :: Put -> ByteString
instance Text.Show.ByteString.Show Data.Binary.Put.Put
instance Text.Show.ByteString.Show ()
instance Text.Show.ByteString.Show GHC.Types.Char
instance Text.Show.ByteString.Show GHC.Types.Bool
instance Text.Show.ByteString.Show a => Text.Show.ByteString.Show [a]
instance Text.Show.ByteString.Show GHC.Types.Int
instance Text.Show.ByteString.Show GHC.Int.Int8
instance Text.Show.ByteString.Show GHC.Int.Int16
instance Text.Show.ByteString.Show GHC.Int.Int32
instance Text.Show.ByteString.Show GHC.Int.Int64
instance Text.Show.ByteString.Show GHC.Types.Word
instance Text.Show.ByteString.Show GHC.Word.Word8
instance Text.Show.ByteString.Show GHC.Word.Word16
instance Text.Show.ByteString.Show GHC.Word.Word32
instance Text.Show.ByteString.Show GHC.Word.Word64
instance Text.Show.ByteString.Show GHC.Integer.Type.Integer
instance Text.Show.ByteString.Show GHC.Types.Float
instance Text.Show.ByteString.Show GHC.Types.Double
instance (Text.Show.ByteString.Show a, GHC.Real.Integral a) => Text.Show.ByteString.Show (GHC.Real.Ratio a)
instance (Text.Show.ByteString.Show a, GHC.Float.RealFloat a) => Text.Show.ByteString.Show (Data.Complex.Complex a)
instance Text.Show.ByteString.Show a => Text.Show.ByteString.Show (GHC.Base.Maybe a)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b) => Text.Show.ByteString.Show (Data.Either.Either a b)
instance Text.Show.ByteString.Show GHC.Types.Ordering
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b) => Text.Show.ByteString.Show (a, b)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b, Text.Show.ByteString.Show c) => Text.Show.ByteString.Show (a, b, c)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b, Text.Show.ByteString.Show c, Text.Show.ByteString.Show d) => Text.Show.ByteString.Show (a, b, c, d)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b, Text.Show.ByteString.Show c, Text.Show.ByteString.Show d, Text.Show.ByteString.Show e) => Text.Show.ByteString.Show (a, b, c, d, e)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b, Text.Show.ByteString.Show c, Text.Show.ByteString.Show d, Text.Show.ByteString.Show e, Text.Show.ByteString.Show f) => Text.Show.ByteString.Show (a, b, c, d, e, f)
instance (Text.Show.ByteString.Show a, Text.Show.ByteString.Show b, Text.Show.ByteString.Show c, Text.Show.ByteString.Show d, Text.Show.ByteString.Show e, Text.Show.ByteString.Show f, Text.Show.ByteString.Show g) => Text.Show.ByteString.Show (a, b, c, d, e, f, g)
instance (Text.Show.ByteString.Show i, Text.Show.ByteString.Show e, GHC.Arr.Ix i) => Text.Show.ByteString.Show (GHC.Arr.Array i e)
instance (Text.Show.ByteString.Show k, Text.Show.ByteString.Show v) => Text.Show.ByteString.Show (Data.Map.Base.Map k v)
instance Text.Show.ByteString.Show e => Text.Show.ByteString.Show (Data.Set.Base.Set e)
