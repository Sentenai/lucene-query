-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package solr-query
@version 0.3.1.0

module Solr.Type

-- | A Solr type.
data SolrType
TNum :: SolrType
TBool :: SolrType
TWord :: SolrType
TWild :: SolrType
TRegex :: SolrType
TPhrase :: SolrType
TFuzzed :: SolrType
TBoosted :: SolrType
TRange :: SolrType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class FuzzableType (a :: SolrType)

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class BoostableType (a :: SolrType)

-- | Types that can appear in a range expression.
class PrimType (a :: SolrType)
instance Solr.Type.FuzzableType 'Solr.Type.TWord
instance Solr.Type.FuzzableType 'Solr.Type.TPhrase
instance Solr.Type.BoostableType 'Solr.Type.TWord
instance Solr.Type.BoostableType 'Solr.Type.TPhrase
instance Solr.Type.PrimType 'Solr.Type.TNum
instance Solr.Type.PrimType 'Solr.Type.TWord


-- | This module defines the finally tagless Solr DSL. This style admits
--   multiple interpreters, one of which (lazy <a>ByteString</a>s) is
--   provided by this library in the <a>Solr.Query</a> module.
--   
--   Users should instead import either <a>Solr.Query</a> or
--   <a>Solr.Qualified.Query</a>.
module Solr.Class

-- | Solr expression.
class SolrExprSYM (expr :: SolrType -> *)

-- | A <tt>num</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>num</a> 5
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | A range expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>incl</a> (<a>num</a> 5) `to` <a>excl</a> (<a>num</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | Solr query.
class SolrExprSYM expr => SolrQuerySYM expr query | query -> expr where data family ParamKey query :: * -> *

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a> 'False 'False
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query False False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query False False -> Float -> query False False

-- | Negate a top-level query.
--   
--   Only a top level query can be negated up to one time, hence the
--   boolean tag that tracks whether or not a query has been negated.
--   
--   Example:
--   
--   <pre>
--   -- -(foo:bar)
--   query :: <a>SolrQuery</a> 'True 'False
--   query = <a>neg</a> ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
neg :: SolrQuerySYM expr query => query False False -> query True False

-- | Add local parameters to a query.
--   
--   Only a top level query can have up to one set of local parameters,
--   hence the boolean tag that tracks whether or not they've been added.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query isNeg False -> query isNeg True

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzed

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>gt</a> (<a>num</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>gte</a> (<a>num</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>lt</a> (<a>num</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>lte</a> (<a>num</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query will require a type annotation.
star :: SolrExprSYM expr => Boundary (expr a)


-- | This module is an alternative to <a>Solr.Class</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Class as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<a>~:</a>)  = <a>fuzz</a>
--   (<a>^:</a>)  = <a>boost</a>
--   (<a>=:</a>)  = <a>field</a>
--   (<a>&amp;&amp;:</a>) = <a>and</a>
--   (<a>||:</a>) = <a>or</a>
--   (<a>-:</a>)  = <a>not</a>
--   (<a>^=:</a>) = <a>score</a>
--   </pre>
module Solr.Qualified.Class

-- | Named version of (<a>~:</a>).
fuzz :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | Named version of (<a>^:</a>).
boost :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | Named version of (<a>=:</a>).
field :: SolrQuerySYM expr query => Text -> expr a -> query False False

-- | Named version of (<a>&amp;&amp;:</a>).
and :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | Named version of (<a>||:</a>).
or :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | Named version of (<a>-:</a>).
not :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | Named version of (<a>^=:</a>).
score :: SolrQuerySYM expr query => query False False -> Float -> query False False


-- | Solr query construction and compilation. You may prefer to import
--   <a>Solr.Qualified.Query</a> instead, which does not export any
--   operators.
module Solr.Query

-- | A Solr query.
--   
--   The two boolean phantom types track whether or not this query has been
--   negated, and whether or not this query has local parameters.
--   
--   While this approach allows fewer bad queries to typecheck, it is not
--   extensible, leaks abstraction, makes documentation more difficult to
--   read, and basically suffers from type-level boolean blindness (a
--   "Could not match True with False" type error is not very helpful). So,
--   this might change eventually.
data SolrQuery (isNeg :: Bool) (hasParams :: Bool)

-- | A Solr filter query. This is like <a>SolrQuery</a>, but with different
--   local parameters available. All functions polymorphic over
--   <a>SolrQuerySYM</a> will work with both.
data SolrFilterQuery (isNeg :: Bool) (hasParams :: Bool)

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a> 'False 'False
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query False False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query False False -> query False False -> query False False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query False False -> Float -> query False False

-- | Negate a top-level query.
--   
--   Only a top level query can be negated up to one time, hence the
--   boolean tag that tracks whether or not a query has been negated.
--   
--   Example:
--   
--   <pre>
--   -- -(foo:bar)
--   query :: <a>SolrQuery</a> 'True 'False
--   query = <a>neg</a> ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
neg :: SolrQuerySYM expr query => query False False -> query True False

-- | Add local parameters to a query.
--   
--   Only a top level query can have up to one set of local parameters,
--   hence the boolean tag that tracks whether or not they've been added.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query isNeg False -> query isNeg True

-- | A Solr expression.
data SolrExpr (t :: SolrType)

-- | A <tt>num</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>num</a> 5
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzed

-- | A range expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>incl</a> (<a>num</a> 5) `to` <a>excl</a> (<a>num</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>gt</a> (<a>num</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>gte</a> (<a>num</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>lt</a> (<a>num</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>lte</a> (<a>num</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a> 'False 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | The class of queries that support the <tt>'df'</tt> local parameter.
class ParamDefaultField query

-- | The <tt>'df'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramDefaultField :: ParamDefaultField query => ParamKey query Text

-- | The class of queries that support the <tt>'op'</tt> local parameter.
class ParamOp query

-- | The <tt>'op'</tt> local parameter.
--   
--   Stringly typed to avoid a clunky sum type like
--   
--   <pre>
--   data Val = And | Or | ...
--   </pre>
--   
--   which seems to have little value in cases like this. Instead, just
--   pass <tt>"AND"</tt>, <tt>"OR"</tt>, ...
--   
--   Example:
--   
--   <pre>
--   -- {!q.op=AND}foo bar
--   query :: <a>SolrQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramOp</a> <a>.=</a> "AND"] (<a>defaultField</a> (<a>word</a> "foo") <a>&lt;&gt;</a> <a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramOp :: ParamOp query => ParamKey query Text

-- | The <tt>'cache'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cache=false}foo:bar
--   query :: <a>SolrFilterQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramCache</a> <a>.=</a> False] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCache :: ParamKey SolrFilterQuery Bool

-- | The <tt>'cost'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cost=5}foo:bar
--   query :: <a>SolrFilterQuery</a> 'False 'True
--   query = <a>params</a> [<a>paramCost</a> <a>.=</a> 5] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCost :: ParamKey SolrFilterQuery Int

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>.
--   
--   Example:
--   
--   <pre>
--   λ let ps = [<a>paramDefaultField</a> <a>.=</a> "body"]
--   λ let q = "foo" =: <a>phrase</a> ["bar", "baz"] <a>~:</a> 5 <a>&amp;&amp;:</a> <a>defaultField</a> (<a>regex</a> "wh?at")
--   λ <a>compileSolrQuery</a> (<a>params</a> ps q)
--   "{!df=body}(foo:\"bar baz\"~5 AND /wh?t/)"
--   </pre>
compileSolrQuery :: SolrQuery isNeg hasParams -> ByteString

-- | Compile a <a>SolrFilterQuery</a> to a lazy <a>ByteString</a>.
compileSolrFilterQuery :: SolrFilterQuery isNeg hasParams -> ByteString
instance Data.Semigroup.Semigroup (Solr.Query.SolrFilterQuery 'GHC.Types.False 'GHC.Types.False)
instance GHC.Base.Monoid (Solr.Query.SolrFilterQuery 'GHC.Types.False 'GHC.Types.False)
instance Data.String.IsString (Solr.Query.SolrExpr 'Solr.Type.TWord)
instance GHC.Exts.IsList (Solr.Query.SolrExpr 'Solr.Type.TPhrase)
instance Solr.Class.SolrExprSYM Solr.Query.SolrExpr
instance Data.Semigroup.Semigroup (Solr.Query.SolrQuery 'GHC.Types.False 'GHC.Types.False)
instance GHC.Base.Monoid (Solr.Query.SolrQuery 'GHC.Types.False 'GHC.Types.False)
instance Solr.Class.SolrQuerySYM Solr.Query.SolrExpr Solr.Query.SolrQuery
instance Solr.Class.SolrQuerySYM Solr.Query.SolrExpr Solr.Query.SolrFilterQuery
instance Solr.Query.ParamDefaultField Solr.Query.SolrQuery
instance Solr.Query.ParamDefaultField Solr.Query.SolrFilterQuery
instance Solr.Query.ParamOp Solr.Query.SolrQuery
instance Solr.Query.ParamOp Solr.Query.SolrFilterQuery


-- | This module is an alternative to <a>Solr.Query</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Query as Solr
--   </pre>
module Solr.Qualified.Query
