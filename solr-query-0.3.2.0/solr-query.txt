-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package solr-query
@version 0.3.2.0

module Solr.Type
data TNum
data TBool
data TWord
data TWild
data TRegex
data TPhrase
data TFuzzed
data TBoosted
data TRange

-- | A Solr type singleton.
data SSolrType ty
STNum :: SSolrType TNum
STBool :: SSolrType TBool
STWord :: SSolrType TWord
STWild :: SSolrType TWild
STRegex :: SSolrType TRegex
STPhrase :: SSolrType TPhrase
STFuzzed :: SSolrType TFuzzed
STBoosted :: SSolrType TBoosted
STRange :: SSolrType TRange
class SolrType ty
solrType :: SolrType ty => SSolrType ty

-- | Structures that are tagged with a Solr type.
class HasSolrType expr
getSolrType :: HasSolrType expr => expr ty -> SSolrType ty

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.

-- | Types that can be boosted by a <tt>'^'</tt> operator.

-- | Types that can appear in a range expression.
instance Solr.Type.SolrType Solr.Type.TNum
instance Solr.Type.SolrType Solr.Type.TBool
instance Solr.Type.SolrType Solr.Type.TWord
instance Solr.Type.SolrType Solr.Type.TWild
instance Solr.Type.SolrType Solr.Type.TRegex
instance Solr.Type.SolrType Solr.Type.TPhrase
instance Solr.Type.SolrType Solr.Type.TFuzzed
instance Solr.Type.SolrType Solr.Type.TBoosted
instance Solr.Type.SolrType Solr.Type.TRange


-- | This module defines the finally tagless Solr DSL. This style admits
--   multiple interpreters, two of which (lazy <a>ByteString</a>s and an
--   initial encoding) are provided by this library, in the
--   <a>Solr.Query</a> and <a>Solr.Query.Initial</a> modules, respectively.
--   
--   Ordinary users should not normally have to import this module.
module Solr.Class

-- | Solr expression.
class SolrExprSYM expr

-- | A <tt>num</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>num</a> 5
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | A range expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>num</a> 5) `to` <a>excl</a> (<a>num</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | Solr query.
class SolrExprSYM expr => SolrQuerySYM expr query | query -> expr where data family ParamKey query :: * -> *

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a>
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query -> Float -> query

-- | Negate a query.
--   
--   Example:
--   
--   <pre>
--   -- -(foo:bar)
--   query :: <a>SolrQuery</a>
--   query = <a>neg</a> ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
neg :: SolrQuerySYM expr query => query -> query

-- | Add local parameters to a query.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query -> query

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzed

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>num</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>num</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>num</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>num</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query will require a type annotation.
star :: SolrExprSYM expr => Boundary (expr a)

module Solr.Param

-- | The class of queries that support the <tt>'df'</tt> local parameter.
class HasParamDefaultField query

-- | The <tt>'df'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramDefaultField :: HasParamDefaultField query => ParamKey query Text

-- | The class of queries that support the <tt>'op'</tt> local parameter.
class HasParamOp query

-- | The <tt>'op'</tt> local parameter.
--   
--   Stringly typed to avoid a clunky sum type like
--   
--   <pre>
--   data Val = And | Or | ...
--   </pre>
--   
--   which seems to have little value in cases like this. Instead, just
--   pass <tt>"AND"</tt>, <tt>"OR"</tt>, ...
--   
--   Example:
--   
--   <pre>
--   -- {!q.op=AND}foo bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramOp</a> <a>.=</a> "AND"] (<a>defaultField</a> (<a>word</a> "foo") <a>&lt;&gt;</a> <a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramOp :: HasParamOp query => ParamKey query Text

-- | The class of queries that support the <tt>'cache'</tt> local
--   parameter.
class HasParamCache query

-- | The <tt>'cache'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cache=false}foo:bar
--   query :: <a>SolrFilterQuery</a>
--   query = <a>params</a> [<a>paramCache</a> <a>.=</a> False] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCache :: HasParamCache query => ParamKey query Bool

-- | The class of queries that support the <tt>'cost'</tt> local parameter.
class HasParamCost query

-- | The <tt>'cost'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cost=5}foo:bar
--   query :: <a>SolrFilterQuery</a>
--   query = <a>params</a> [<a>paramCost</a> <a>.=</a> 5] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCost :: HasParamCost query => ParamKey query Int


-- | This module is an alternative to <a>Solr.Class</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Class as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<a>~:</a>)  = <a>fuzz</a>
--   (<a>^:</a>)  = <a>boost</a>
--   (<a>=:</a>)  = <a>field</a>
--   (<a>&amp;&amp;:</a>) = <a>and</a>
--   (<a>||:</a>) = <a>or</a>
--   (<a>-:</a>)  = <a>not</a>
--   (<a>^=:</a>) = <a>score</a>
--   </pre>
module Solr.Qualified.Class

-- | Named version of (<a>~:</a>).
fuzz :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | Named version of (<a>^:</a>).
boost :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | Named version of (<a>=:</a>).
field :: SolrQuerySYM expr query => Text -> expr a -> query

-- | Named version of (<a>&amp;&amp;:</a>).
and :: SolrQuerySYM expr query => query -> query -> query

-- | Named version of (<a>||:</a>).
or :: SolrQuerySYM expr query => query -> query -> query

-- | Named version of (<a>-:</a>).
not :: SolrQuerySYM expr query => query -> query -> query

-- | Named version of (<a>^=:</a>).
score :: SolrQuerySYM expr query => query -> Float -> query


-- | Solr query construction and compilation. You may prefer to import
--   <a>Solr.Qualified.Query</a> instead, which does not export any
--   operators.
module Solr.Query

-- | A Solr query.
data SolrQuery

-- | A Solr filter query. This is like <a>SolrQuery</a>, but with different
--   local parameters available. All functions polymorphic over
--   <a>SolrQuerySYM</a> will work with both.
data SolrFilterQuery

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a>
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query -> Float -> query

-- | Negate a query.
--   
--   Example:
--   
--   <pre>
--   -- -(foo:bar)
--   query :: <a>SolrQuery</a>
--   query = <a>neg</a> ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
neg :: SolrQuerySYM expr query => query -> query

-- | Add local parameters to a query.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query -> query

-- | A Solr expression.
data SolrExpr t

-- | A <tt>num</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>num</a> 5
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr TFuzzed

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzed

-- | A range expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>num</a> 5) `to` <a>excl</a> (<a>num</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>num</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>num</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>num</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>num</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr TBoosted

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | The class of queries that support the <tt>'df'</tt> local parameter.
class HasParamDefaultField query

-- | The <tt>'df'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramDefaultField</a> <a>.=</a> "foo"] (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramDefaultField :: HasParamDefaultField query => ParamKey query Text

-- | The class of queries that support the <tt>'op'</tt> local parameter.
class HasParamOp query

-- | The <tt>'op'</tt> local parameter.
--   
--   Stringly typed to avoid a clunky sum type like
--   
--   <pre>
--   data Val = And | Or | ...
--   </pre>
--   
--   which seems to have little value in cases like this. Instead, just
--   pass <tt>"AND"</tt>, <tt>"OR"</tt>, ...
--   
--   Example:
--   
--   <pre>
--   -- {!q.op=AND}foo bar
--   query :: <a>SolrQuery</a>
--   query = <a>params</a> [<a>paramOp</a> <a>.=</a> "AND"] (<a>defaultField</a> (<a>word</a> "foo") <a>&lt;&gt;</a> <a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramOp :: HasParamOp query => ParamKey query Text

-- | The class of queries that support the <tt>'cache'</tt> local
--   parameter.
class HasParamCache query

-- | The <tt>'cache'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cache=false}foo:bar
--   query :: <a>SolrFilterQuery</a>
--   query = <a>params</a> [<a>paramCache</a> <a>.=</a> False] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCache :: HasParamCache query => ParamKey query Bool

-- | The class of queries that support the <tt>'cost'</tt> local parameter.
class HasParamCost query

-- | The <tt>'cost'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!cost=5}foo:bar
--   query :: <a>SolrFilterQuery</a>
--   query = <a>params</a> [<a>paramCost</a> <a>.=</a> 5] ("foo" <a>=:</a> <a>word</a> "bar")
--   </pre>
paramCost :: HasParamCost query => ParamKey query Int

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>.
--   
--   Example:
--   
--   <pre>
--   λ let ps = [<a>paramDefaultField</a> <a>.=</a> "body"]
--   λ let q = "foo" =: <a>phrase</a> ["bar", "baz"] <a>~:</a> 5 <a>&amp;&amp;:</a> <a>defaultField</a> (<a>regex</a> "wh?at")
--   λ <a>compileSolrQuery</a> (<a>params</a> ps q)
--   "{!df=body }(foo:\"bar baz\"~5 AND /wh?t/)"
--   </pre>
compileSolrQuery :: SolrQuery -> ByteString

-- | Compile a <a>SolrFilterQuery</a> to a lazy <a>ByteString</a>.
compileSolrFilterQuery :: SolrFilterQuery -> ByteString
instance Data.Semigroup.Semigroup Solr.Query.SolrFilterQuery
instance GHC.Base.Monoid Solr.Query.SolrFilterQuery
instance Data.String.IsString (Solr.Query.SolrExpr Solr.Type.TWord)
instance GHC.Exts.IsList (Solr.Query.SolrExpr Solr.Type.TPhrase)
instance Solr.Class.SolrExprSYM Solr.Query.SolrExpr
instance Data.Semigroup.Semigroup Solr.Query.SolrQuery
instance GHC.Base.Monoid Solr.Query.SolrQuery
instance Solr.Class.SolrQuerySYM Solr.Query.SolrExpr Solr.Query.SolrQuery
instance Solr.Param.HasParamDefaultField Solr.Query.SolrQuery
instance Solr.Param.HasParamOp Solr.Query.SolrQuery
instance Solr.Class.SolrQuerySYM Solr.Query.SolrExpr Solr.Query.SolrFilterQuery
instance Solr.Param.HasParamDefaultField Solr.Query.SolrFilterQuery
instance Solr.Param.HasParamOp Solr.Query.SolrFilterQuery
instance Solr.Param.HasParamCache Solr.Query.SolrFilterQuery
instance Solr.Param.HasParamCost Solr.Query.SolrFilterQuery


-- | This module is an alternative to <a>Solr.Query</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Query as Solr
--   </pre>
module Solr.Qualified.Query


-- | An initial encoding of a Solr query. This is an alternative
--   interpretation of the Solr language that is more amenable to parsing
--   from arbitrary user input.
module Solr.Query.Initial

-- | A Solr query.
data SolrQueryI
QDefaultField :: SolrExprI a -> SolrQueryI
QField :: Text -> SolrExprI a -> SolrQueryI
QAnd :: SolrQueryI -> SolrQueryI -> SolrQueryI
QOr :: SolrQueryI -> SolrQueryI -> SolrQueryI
QNot :: SolrQueryI -> SolrQueryI -> SolrQueryI
QScore :: SolrQueryI -> Float -> SolrQueryI
QNeg :: SolrQueryI -> SolrQueryI
QParams :: [Param SolrQueryI] -> SolrQueryI -> SolrQueryI

-- | A Solr expression.
data SolrExprI ty
ENum :: Float -> SolrExprI TNum
ETrue :: SolrExprI TBool
EFalse :: SolrExprI TBool
EWord :: Text -> SolrExprI TWord
EWild :: Text -> SolrExprI TWild
ERegex :: Text -> SolrExprI TRegex
EPhrase :: [SolrExprI TWord] -> SolrExprI TPhrase
EFuzz :: SolrExprI a -> Int -> SolrExprI TFuzzed
ETo :: Boundary (SolrExprI a) -> Boundary (SolrExprI a) -> SolrExprI TRange
EBoost :: SolrExprI a -> Float -> SolrExprI TBoosted

-- | Select the <a>SolrQueryI</a> interpreter.
--   
--   <pre>
--   solrQueryI = id
--   </pre>
solrQueryI :: SolrQueryI -> SolrQueryI

-- | An untyped Solr query.
data USolrQueryI
UQDefaultField :: USolrExprI -> USolrQueryI
UQField :: Text -> USolrExprI -> USolrQueryI
UQAnd :: USolrQueryI -> USolrQueryI -> USolrQueryI
UQOr :: USolrQueryI -> USolrQueryI -> USolrQueryI
UQNot :: USolrQueryI -> USolrQueryI -> USolrQueryI
UQScore :: USolrQueryI -> Float -> USolrQueryI
UQNeg :: USolrQueryI -> USolrQueryI

-- | An untyped Solr expression.
data USolrExprI
UENum :: Float -> USolrExprI
UETrue :: USolrExprI
UEFalse :: USolrExprI
UEWord :: Text -> USolrExprI
UEWild :: Text -> USolrExprI
UERegex :: Text -> USolrExprI
UEPhrase :: [USolrExprI] -> USolrExprI
UEFuzz :: USolrExprI -> Int -> USolrExprI
UETo :: (Boundary USolrExprI) -> (Boundary USolrExprI) -> USolrExprI
UEBoost :: USolrExprI -> Float -> USolrExprI
typeCheckSolrQuery :: USolrQueryI -> r -> (SolrQueryI -> r) -> r
instance Solr.Type.HasSolrType Solr.Query.Initial.SolrExprI
instance Solr.Class.SolrExprSYM Solr.Query.Initial.SolrExprI
instance Solr.Class.SolrQuerySYM Solr.Query.Initial.SolrExprI Solr.Query.Initial.SolrQueryI
instance Solr.Param.HasParamDefaultField Solr.Query.Initial.SolrQueryI
instance Solr.Param.HasParamOp Solr.Query.Initial.SolrQueryI
