-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solr query EDSL
--   
--   Solr query EDSL
@package solr-query
@version 0.3.5.0

module Solr.Type
data SolrType
TNum :: SolrType
TBool :: SolrType
TWord :: SolrType
TWild :: SolrType
TRegex :: SolrType
TPhrase :: SolrType
TFuzzed :: SolrType -> SolrType
TBoosted :: SolrType -> SolrType
TRanged :: SolrType -> SolrType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class Fuzzable (ty :: SolrType)

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class Boostable (ty :: SolrType)

-- | Types that can appear in a <tt><tt>TO</tt></tt> range expression.
class Rangeable (ty :: SolrType)
instance Solr.Type.Fuzzable 'Solr.Type.TWord
instance Solr.Type.Fuzzable 'Solr.Type.TPhrase
instance Solr.Type.Boostable 'Solr.Type.TWord
instance Solr.Type.Boostable 'Solr.Type.TPhrase
instance Solr.Type.Rangeable 'Solr.Type.TNum
instance Solr.Type.Rangeable 'Solr.Type.TWord

module Solr.Internal.Class.Expr

-- | Solr expression.
class SolrExprSYM expr

-- | A <tt>num</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: num 5 :: SolrQuery SolrExpr
--   q=foo:5.0
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: true :: SolrQuery SolrExpr
--   q=foo:true
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: false :: SolrQuery SolrExpr
--   q=foo:false
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" :: SolrQuery SolrExpr
--   q=foo:bar
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: wild "b?r" :: SolrQuery SolrExpr
--   q=foo:b?r
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: regex "[mb]oat" :: SolrQuery SolrExpr
--   q=foo:/[mb]oat/
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz"] :: SolrQuery SolrExpr
--   q=foo:"bar baz"
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ~: 1 :: SolrQuery SolrExpr
--   q=foo:bar~1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz", "qux"] ~: 10 :: SolrQuery SolrExpr
--   q=foo:"bar baz qux"~10
--   </pre>
(~:) :: (SolrExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: incl (num 5) `to` excl (num 10) :: SolrQuery SolrExpr
--   q=foo:[5.0 TO 10.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: excl (word "bar") `to` star :: SolrQuery SolrExpr
--   q=foo:{bar TO *]
--   </pre>
--   
--   <ul>
--   <li>- Note the explicit type signature required for <tt>[* TO *]</tt>
--   queries &gt;&gt;&gt; "foo" =: star <a>to</a> (star :: Boundary
--   (SolrExpr 'TNum)) :: SolrQuery SolrExpr q=foo:[* TO *]</li>
--   </ul>
to :: (SolrExprSYM expr, Rangeable a) => Boundary (expr a) -> Boundary (expr a) -> expr (TRanged a)

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ^: 3.5 :: SolrQuery SolrExpr
--   q=foo:bar^3.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz"] ^: 3.5 :: SolrQuery SolrExpr
--   q=foo:"bar baz"^3.5
--   </pre>
(^:) :: (SolrExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: fuzzy "bar" :: SolrQuery SolrExpr
--   q=foo:bar~2
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr (TFuzzed TWord)

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: gt (num 5) :: SolrQuery SolrExpr
--   q=foo:{5.0 TO *]
--   </pre>
gt :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: gte (num 5) :: SolrQuery SolrExpr
--   q=foo:[5.0 TO *]
--   </pre>
gte :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: lt (num 5) :: SolrQuery SolrExpr
--   q=foo:[* TO 5.0}
--   </pre>
lt :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: lte (num 5) :: SolrQuery SolrExpr
--   q=foo:[* TO 5.0]
--   </pre>
lte :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query will require a type annotation.
star :: SolrExprSYM expr => Boundary (expr a)

-- | Named version of (<a>~:</a>).
fuzz :: (SolrExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | Named version of (<a>^:</a>).
boost :: (SolrExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)
instance GHC.Base.Functor Solr.Internal.Class.Expr.Boundary
instance GHC.Show.Show a => GHC.Show.Show (Solr.Internal.Class.Expr.Boundary a)

module Solr.Expr.Initial.Untyped

-- | An untyped, initially-encoded Solr expression.
data SolrExpr (a :: SolrType)
ENum :: Float -> SolrExpr
ETrue :: SolrExpr
EFalse :: SolrExpr
EWord :: Text -> SolrExpr
EWild :: Text -> SolrExpr
ERegex :: Text -> SolrExpr
EPhrase :: [SolrExpr b] -> SolrExpr
EFuzz :: (SolrExpr b) -> Int -> SolrExpr
ETo :: (Boundary (SolrExpr b)) -> (Boundary (SolrExpr b)) -> SolrExpr
EBoost :: (SolrExpr b) -> Float -> SolrExpr
instance GHC.Show.Show (Solr.Expr.Initial.Untyped.SolrExpr a)
instance Solr.Internal.Class.Expr.SolrExprSYM Solr.Expr.Initial.Untyped.SolrExpr

module Solr.Expr.Initial.Typed

-- | A typed, initially-encoded Solr expression.
data SolrExpr :: SolrType -> *
ENum :: Float -> SolrExpr TNum
ETrue :: SolrExpr TBool
EFalse :: SolrExpr TBool
EWord :: Text -> SolrExpr TWord
EWild :: Text -> SolrExpr TWild
ERegex :: Text -> SolrExpr TRegex
EPhrase :: [SolrExpr TWord] -> SolrExpr TPhrase
EFuzz :: SolrExpr a -> Int -> SolrExpr (TFuzzed a)
ETo :: Boundary (SolrExpr a) -> Boundary (SolrExpr a) -> SolrExpr (TRanged a)
EBoost :: SolrExpr a -> Float -> SolrExpr (TBoosted a)

-- | Existential wrapper around <a>SolrExpr</a>.
data SomeSolrExpr
SomeSolrExpr :: (SolrExpr ty) -> SomeSolrExpr

-- | Type check an untyped Solr expression. Note the untyped
--   <a>SolrExpr</a> on the way in is not the same as the typed
--   <a>SolrExpr</a> on the way out.
--   
--   <pre>
--   <a>typeCheckSolrExpr</a> u k =
--     case <a>typeCheckSolrExpr'</a> u of
--       Nothing -&gt; k Nothing
--       Just (<a>SomeSolrExpr</a> e) -&gt; k (Just e)
--   </pre>
typeCheckSolrExpr :: SolrExpr a -> (forall ty. Maybe (SolrExpr ty) -> r) -> r

-- | Like <a>typeCheckSolrExpr</a>, but return an existential type rather
--   than use rank-2 continuation passing style, if you prefer.
typeCheckSolrExpr' :: SolrExpr a -> Maybe SomeSolrExpr

-- | Reinterpret a Solr expression.
reinterpretSolrExpr :: SolrExprSYM expr => SolrExpr ty -> expr ty
instance Solr.Internal.Class.Expr.SolrExprSYM Solr.Expr.Initial.Typed.SolrExpr


-- | This module defines the finally tagless Solr DSL. This style admits
--   multiple interpreters, two of which (lazy <a>ByteString</a>s and an
--   initial encoding) are provided by this library, in the
--   <a>Solr.Query</a> and <a>Solr.Query.Initial</a> modules, respectively.
--   
--   Ordinary users should not normally have to import this module.
module Solr.Internal.Class.Query

-- | Solr query language.
class SolrExprSYM expr => SolrQuerySYM expr query where data family ParamKey query :: * -> *

-- | A default field query.
--   
--   <pre>
--   &gt;&gt;&gt; defaultField (word "foo") :: SolrQuery SolrExpr
--   q=foo
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query expr

-- | A field query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" :: SolrQuery SolrExpr
--   q=foo:bar
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query expr

-- | An <tt>AND</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" &amp;&amp;: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar AND baz:qux)
--   </pre>
(&&:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | An <tt>OR</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ||: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar OR baz:qux)
--   </pre>
(||:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" -: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar NOT baz:qux)
--   </pre>
(-:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ^=: 3.5 :: SolrQuery SolrExpr
--   q=foo:bar^=3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query expr -> Float -> query expr

-- | Negate a query.
--   
--   <pre>
--   &gt;&gt;&gt; neg ("foo" =: word "bar") :: SolrQuery SolrExpr
--   q=-foo:bar
--   </pre>
neg :: SolrQuerySYM expr query => query expr -> query expr

-- | Add local parameters to a query.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramDefaultField .= "foo"] (defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!df=foo}bar
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query expr -> query expr

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | Named version of (<a>=:</a>).
field :: SolrQuerySYM expr query => Text -> expr a -> query expr

-- | Named version of (<a>&amp;&amp;:</a>).
and :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>||:</a>).
or :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>-:</a>).
not :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>^=:</a>).
score :: SolrQuerySYM expr query => query expr -> Float -> query expr


-- | Query parameters.
module Solr.Query.Param

-- | The class of queries that support the <tt>'df'</tt> local parameter.
class HasParamDefaultField (query :: (SolrType -> *) -> *)

-- | The <tt>'df'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramDefaultField .= "foo"] (defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!df=foo}bar
--   </pre>
paramDefaultField :: HasParamDefaultField query => ParamKey query Text

-- | The class of queries that support the <tt>'op'</tt> local parameter.
class HasParamOp query

-- | The <tt>'op'</tt> local parameter.
--   
--   Stringly typed to avoid a clunky sum type like
--   
--   <pre>
--   data Operator = And | Or | ...
--   </pre>
--   
--   which seems to have little value in cases like this. Instead, just
--   pass <tt>"AND"</tt>, <tt>"OR"</tt>, ...
--   
--   <pre>
--   &gt;&gt;&gt; params [paramOp .= "AND"] (defaultField (word "foo") &lt;&gt; defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!q.op=AND}foo bar
--   </pre>
paramOp :: HasParamOp query => ParamKey query Text

-- | The class of queries that support the <tt>'cache'</tt> local
--   parameter.
class HasParamCache query

-- | The <tt>'cache'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramCache .= False] ("foo" =: word "bar") :: SolrFilterQuery SolrExpr
--   fq={!cache=false}foo:bar
--   </pre>
paramCache :: HasParamCache query => ParamKey query Bool

-- | The class of queries that support the <tt>'cost'</tt> local parameter.
class HasParamCost query

-- | The <tt>'cost'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramCost .= 5] ("foo" =: word "bar") :: SolrFilterQuery SolrExpr
--   fq={!cost=5}foo:bar
--   </pre>
paramCost :: HasParamCost query => ParamKey query Int


-- | An initial encoding of a Solr query. This is an alternative
--   interpretation of the Solr language that is more amenable to parsing
--   from arbitrary user input and applying query transformations.
module Solr.Query.Initial

-- | An initial encoding of a Solr query.
data SolrQuery expr
QDefaultField :: (expr a) -> SolrQuery expr
QField :: Text -> (expr a) -> SolrQuery expr
QAnd :: (SolrQuery expr) -> (SolrQuery expr) -> SolrQuery expr
QOr :: (SolrQuery expr) -> (SolrQuery expr) -> SolrQuery expr
QNot :: (SolrQuery expr) -> (SolrQuery expr) -> SolrQuery expr
QScore :: (SolrQuery expr) -> Float -> SolrQuery expr
QNeg :: (SolrQuery expr) -> SolrQuery expr
QParams :: [Param SolrQuery] -> (SolrQuery expr) -> SolrQuery expr
QAppend :: (SolrQuery expr) -> (SolrQuery expr) -> SolrQuery expr

-- | Type check an untyped Solr query. Note the untyped <a>SolrExpr</a> on
--   the way in is not the same as the typed <a>SolrExpr</a> on the way
--   out.
typeCheckSolrQuery :: SolrQuery SolrExpr -> Maybe (SolrQuery SolrExpr)

-- | Attempt to factor a Solr query into a canonical form that irons out
--   invalid queries that are not caught by the type system (for example,
--   double-negation, or multiple nested applications of <a>params</a>).
--   
--   Check the source code for all transformations performed.
factorSolrQuery :: SolrQuery expr -> SolrQuery expr

-- | Reinterpret an initially-encoded <a>SolrQuery</a> to some other
--   interpretation that supports all of 'SolrQuery'\'s params.
--   
--   This may be useful for reinterpreting a <a>SolrQuery</a> as a lazy
--   <a>ByteString</a> after it's been type checked and factored with the
--   machinery in this module.
reinterpretSolrQuery :: (SolrQuerySYM expr query, HasParamDefaultField query, HasParamOp query, Semigroup (query expr)) => SolrQuery SolrExpr -> query expr
instance Data.Constraint.Forall.ForallF GHC.Show.Show expr => GHC.Show.Show (Solr.Query.Initial.SolrQuery expr)
instance Data.Semigroup.Semigroup (Solr.Query.Initial.SolrQuery expr)
instance Data.Generics.Uniplate.Operations.Uniplate (Solr.Query.Initial.SolrQuery expr)
instance Solr.Internal.Class.Expr.SolrExprSYM expr => Solr.Internal.Class.Query.SolrQuerySYM expr Solr.Query.Initial.SolrQuery
instance GHC.Show.Show (Solr.Internal.Class.Query.Param Solr.Query.Initial.SolrQuery)
instance Solr.Query.Param.HasParamDefaultField Solr.Query.Initial.SolrQuery
instance Solr.Query.Param.HasParamOp Solr.Query.Initial.SolrQuery

module Solr.Expr

-- | <pre>
--   <a>SolrExpr</a> :: <a>SolrType</a> -&gt; *
--   </pre>
--   
--   An opaque Solr expression, indexed by its <a>SolrType</a>. Its
--   interpretation, accessed via e.g. <a>compileSolrQuery</a>, is a lazy
--   <a>ByteString</a>.
--   
--   For an initially-encoded version, see <a>Solr.Expr.Untyped</a> or
--   <a>Solr.Expr.Typed</a>.
data SolrExpr (t :: SolrType)


-- | Solr query construction and compilation. This is the simplest
--   interpretation of the Solr query language as a lazy <a>ByteString</a>.
--   
--   This module re-exports the expression and query languages from
--   <a>Solr.Internal.Class.Query</a> <i>inline</i>, for ease of browsing
--   the haddocks. Other modules simply re-export those modules whole.
--   
--   Not all type-correct expressions using the Solr DSL result in
--   well-formed queries. For example,
--   
--   <pre>
--   &gt;&gt;&gt; type C query expr = (SolrQuerySYM expr query, HasParamDefaultField query, HasParamOp query)
--   
--   &gt;&gt;&gt; :{
--    let p1    = [paramDefaultField .= "foo"]
--        p2    = [paramOp .= "AND"]
--        q0    = defaultField (word "bar")
--        query = params p1 (params p2 q0) :: C query expr =&gt; query expr
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; query :: SolrQuery SolrExpr
--   q={!df=foo}{!q.op=AND}bar
--   </pre>
--   
--   For this reason, you may want to first interpret a query using
--   <a>Solr.Query.Initial</a>, manually fix up the AST (perhaps with
--   <a>factorSolrQuery</a>), and then reinterpret it as the lazy
--   <a>ByteString</a> version using <a>reinterpretSolrQuery</a>:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Solr.Query.Initial as Q
--   
--   &gt;&gt;&gt; import qualified Solr.Expr.Initial.Typed as E
--   
--   &gt;&gt;&gt; Q.reinterpretSolrQuery (Q.factorSolrQuery query) :: SolrQuery SolrExpr
--   q={!df=foo q.op=AND}bar
--   </pre>
module Solr.Query

-- | A Solr query.
data SolrQuery (expr :: SolrType -> *)

-- | A Solr filter query. This is like <a>SolrQuery</a>, but with different
--   local parameters available. All functions polymorphic over
--   <a>SolrQuerySYM</a> will work with both.
data SolrFilterQuery expr

-- | A default field query.
--   
--   <pre>
--   &gt;&gt;&gt; defaultField (word "foo") :: SolrQuery SolrExpr
--   q=foo
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query expr

-- | A field query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" :: SolrQuery SolrExpr
--   q=foo:bar
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query expr

-- | Named version of (<a>=:</a>).
field :: SolrQuerySYM expr query => Text -> expr a -> query expr

-- | An <tt>AND</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" &amp;&amp;: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar AND baz:qux)
--   </pre>
(&&:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>&amp;&amp;:</a>).
and :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | An <tt>OR</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ||: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar OR baz:qux)
--   </pre>
(||:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>||:</a>).
or :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" -: "baz" =: word "qux" :: SolrQuery SolrExpr
--   q=(foo:bar NOT baz:qux)
--   </pre>
(-:) :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | Named version of (<a>-:</a>).
not :: SolrQuerySYM expr query => query expr -> query expr -> query expr

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ^=: 3.5 :: SolrQuery SolrExpr
--   q=foo:bar^=3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query expr -> Float -> query expr

-- | Named version of (<a>^=:</a>).
score :: SolrQuerySYM expr query => query expr -> Float -> query expr

-- | Negate a query.
--   
--   <pre>
--   &gt;&gt;&gt; neg ("foo" =: word "bar") :: SolrQuery SolrExpr
--   q=-foo:bar
--   </pre>
neg :: SolrQuerySYM expr query => query expr -> query expr

-- | Add local parameters to a query.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramDefaultField .= "foo"] (defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!df=foo}bar
--   </pre>
params :: SolrQuerySYM expr query => [Param query] -> query expr -> query expr

-- | <pre>
--   <a>SolrExpr</a> :: <a>SolrType</a> -&gt; *
--   </pre>
--   
--   An opaque Solr expression, indexed by its <a>SolrType</a>. Its
--   interpretation, accessed via e.g. <a>compileSolrQuery</a>, is a lazy
--   <a>ByteString</a>.
--   
--   For an initially-encoded version, see <a>Solr.Expr.Untyped</a> or
--   <a>Solr.Expr.Typed</a>.
data SolrExpr (t :: SolrType)

-- | A <tt>num</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: num 5 :: SolrQuery SolrExpr
--   q=foo:5.0
--   </pre>
num :: SolrExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: true :: SolrQuery SolrExpr
--   q=foo:true
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: false :: SolrQuery SolrExpr
--   q=foo:false
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" :: SolrQuery SolrExpr
--   q=foo:bar
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: wild "b?r" :: SolrQuery SolrExpr
--   q=foo:b?r
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: regex "[mb]oat" :: SolrQuery SolrExpr
--   q=foo:/[mb]oat/
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz"] :: SolrQuery SolrExpr
--   q=foo:"bar baz"
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ~: 1 :: SolrQuery SolrExpr
--   q=foo:bar~1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz", "qux"] ~: 10 :: SolrQuery SolrExpr
--   q=foo:"bar baz qux"~10
--   </pre>
(~:) :: (SolrExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | Named version of (<a>~:</a>).
fuzz :: (SolrExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: fuzzy "bar" :: SolrQuery SolrExpr
--   q=foo:bar~2
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr (TFuzzed TWord)

-- | A range expression.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: incl (num 5) `to` excl (num 10) :: SolrQuery SolrExpr
--   q=foo:[5.0 TO 10.0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: excl (word "bar") `to` star :: SolrQuery SolrExpr
--   q=foo:{bar TO *]
--   </pre>
--   
--   <ul>
--   <li>- Note the explicit type signature required for <tt>[* TO *]</tt>
--   queries &gt;&gt;&gt; "foo" =: star <a>to</a> (star :: Boundary
--   (SolrExpr 'TNum)) :: SolrQuery SolrExpr q=foo:[* TO *]</li>
--   </ul>
to :: (SolrExprSYM expr, Rangeable a) => Boundary (expr a) -> Boundary (expr a) -> expr (TRanged a)

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query will require a type annotation.
star :: SolrExprSYM expr => Boundary (expr a)

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: gt (num 5) :: SolrQuery SolrExpr
--   q=foo:{5.0 TO *]
--   </pre>
gt :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: gte (num 5) :: SolrQuery SolrExpr
--   q=foo:[5.0 TO *]
--   </pre>
gte :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: lt (num 5) :: SolrQuery SolrExpr
--   q=foo:[* TO 5.0}
--   </pre>
lt :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: lte (num 5) :: SolrQuery SolrExpr
--   q=foo:[* TO 5.0]
--   </pre>
lte :: (SolrExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: word "bar" ^: 3.5 :: SolrQuery SolrExpr
--   q=foo:bar^3.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" =: phrase ["bar", "baz"] ^: 3.5 :: SolrQuery SolrExpr
--   q=foo:"bar baz"^3.5
--   </pre>
(^:) :: (SolrExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)

-- | Named version of (<a>^:</a>).
boost :: (SolrExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)

-- | A parameter is built from a key and a value, whose type depends on the
--   key.
data Param query
Param :: ParamKey query val -> val -> Param query

-- | Infix constructor for <a>Param</a>.
(.=) :: ParamKey query val -> val -> Param query

-- | The class of queries that support the <tt>'df'</tt> local parameter.
class HasParamDefaultField (query :: (SolrType -> *) -> *)

-- | The <tt>'df'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramDefaultField .= "foo"] (defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!df=foo}bar
--   </pre>
paramDefaultField :: HasParamDefaultField query => ParamKey query Text

-- | The class of queries that support the <tt>'op'</tt> local parameter.
class HasParamOp query

-- | The <tt>'op'</tt> local parameter.
--   
--   Stringly typed to avoid a clunky sum type like
--   
--   <pre>
--   data Operator = And | Or | ...
--   </pre>
--   
--   which seems to have little value in cases like this. Instead, just
--   pass <tt>"AND"</tt>, <tt>"OR"</tt>, ...
--   
--   <pre>
--   &gt;&gt;&gt; params [paramOp .= "AND"] (defaultField (word "foo") &lt;&gt; defaultField (word "bar")) :: SolrQuery SolrExpr
--   q={!q.op=AND}foo bar
--   </pre>
paramOp :: HasParamOp query => ParamKey query Text

-- | The class of queries that support the <tt>'cache'</tt> local
--   parameter.
class HasParamCache query

-- | The <tt>'cache'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramCache .= False] ("foo" =: word "bar") :: SolrFilterQuery SolrExpr
--   fq={!cache=false}foo:bar
--   </pre>
paramCache :: HasParamCache query => ParamKey query Bool

-- | The class of queries that support the <tt>'cost'</tt> local parameter.
class HasParamCost query

-- | The <tt>'cost'</tt> local parameter.
--   
--   <pre>
--   &gt;&gt;&gt; params [paramCost .= 5] ("foo" =: word "bar") :: SolrFilterQuery SolrExpr
--   fq={!cost=5}foo:bar
--   </pre>
paramCost :: HasParamCost query => ParamKey query Int

-- | Compile a <a>SolrQuery</a> to a lazy <tt>ByteString</tt>.
--   
--   Note that the DSL admits many ways to create an invalid Solr query;
--   that is, if it compiles, it doesn't necessarily work. For example,
--   multiple <a>neg</a>s on a query, multiple <a>params</a>, etc.
--   
--   <pre>
--   &gt;&gt;&gt; let ps = [paramDefaultField .= "body"]
--   
--   &gt;&gt;&gt; let q = "foo" =: phrase ["bar", "baz"] ~: 5 &amp;&amp;: defaultField (regex "wh?t") :: SolrQuery SolrExpr
--   
--   &gt;&gt;&gt; compileSolrQuery (params ps q)
--   "q={!df=body}(foo:\"bar baz\"~5 AND /wh?t/)"
--   </pre>
compileSolrQuery :: SolrQuery expr -> ByteString

-- | Compile a <a>SolrFilterQuery</a> to a lazy <tt>ByteString</tt>.
compileSolrFilterQuery :: SolrFilterQuery expr -> ByteString
instance Data.Semigroup.Semigroup (Solr.Query.SolrFilterQuery expr)
instance GHC.Show.Show (Solr.Query.SolrQuery expr)
instance Data.Semigroup.Semigroup (Solr.Query.SolrQuery expr)
instance Solr.Internal.Class.Query.SolrQuerySYM Solr.Expr.Internal.SolrExpr Solr.Query.SolrQuery
instance Solr.Query.Param.HasParamDefaultField Solr.Query.SolrQuery
instance Solr.Query.Param.HasParamOp Solr.Query.SolrQuery
instance GHC.Show.Show (Solr.Query.SolrFilterQuery expr)
instance Solr.Internal.Class.Query.SolrQuerySYM Solr.Expr.Internal.SolrExpr Solr.Query.SolrFilterQuery
instance Solr.Query.Param.HasParamDefaultField Solr.Query.SolrFilterQuery
instance Solr.Query.Param.HasParamOp Solr.Query.SolrFilterQuery
instance Solr.Query.Param.HasParamCache Solr.Query.SolrFilterQuery
instance Solr.Query.Param.HasParamCost Solr.Query.SolrFilterQuery
