-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package solr-query
@version 0.2.2.0

module Solr.Type

-- | A Solr type.
data SolrType
TInt :: SolrType
TBool :: SolrType
TWord :: SolrType
TFuzzyWord :: SolrType
TBoostedWord :: SolrType
TWild :: SolrType
TRegex :: SolrType
TPhrase :: SolrType
TFuzzyPhrase :: SolrType
TBoostedPhrase :: SolrType
TRange :: SolrType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class FuzzableType (a :: SolrType) where type family TFuzzed a :: SolrType

-- | <pre>
--   type TFuzzed TWord = TFuzzyWord
--   </pre>

-- | <pre>
--   type TFuzzed TPhrase = TFuzzyPhrase
--   </pre>

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class BoostableType (a :: SolrType) where type family TBoosted a :: SolrType

-- | <pre>
--   type TBoosted TWord = TBoostedWord
--   </pre>

-- | <pre>
--   type TBoosted TPhrase = TBoostedPhrase
--   </pre>

-- | Types that can appear in a range expression.
class PrimType (a :: SolrType)
instance Solr.Type.FuzzableType 'Solr.Type.TWord
instance Solr.Type.FuzzableType 'Solr.Type.TPhrase
instance Solr.Type.BoostableType 'Solr.Type.TWord
instance Solr.Type.BoostableType 'Solr.Type.TPhrase
instance Solr.Type.PrimType 'Solr.Type.TWord
instance Solr.Type.PrimType 'Solr.Type.TInt


-- | This module defines the Solr DSL. Ordinary users should instead import
--   either <a>Solr.Query</a> or <a>Solr.Query.Qualified</a>.
module Solr.Class

-- | The finally tagless Solr class. This admits multiple interpreters,
--   with one (lazy <a>ByteString</a>s) provided by this library, in the
--   <a>Solr.Query</a> module.
--   
--   For simplicity, the type signatures in the examples below monomorphise
--   the functions to use <a>SolrQuery</a> (and therefore <a>SolrExpr</a>,
--   due to the functional dependency).
class Solr expr query | query -> expr, expr -> query

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Solr expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Solr expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Solr expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: Solr expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Solr expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Solr expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Solr expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (Solr expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (Solr expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (Solr expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Solr expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Solr expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Solr expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Solr expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: Solr expr query => query -> Float -> query

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: Solr expr query => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: Solr expr query => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: Solr expr query => expr a -> Boundary (expr a)
star :: Solr expr query => Boundary (expr a)


-- | This module is an alternative to <a>Solr.Class</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Class.Qualified as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<tt>~:</tt>)  = <a>fuzz</a>
--   (<tt>^:</tt>)  = <a>boost</a>
--   (<tt>=:</tt>)  = <a>field</a>
--   (<tt>&amp;&amp;:</tt>) = <a>and</a>
--   (<tt>||:</tt>) = <a>or</a>
--   (<tt>-:</tt>)  = <a>not</a>
--   (<tt>^=:</tt>) = <a>score</a>
--   </pre>
module Solr.Class.Qualified

-- | The finally tagless Solr class. This admits multiple interpreters,
--   with one (lazy <a>ByteString</a>s) provided by this library, in the
--   <a>Solr.Query</a> module.
--   
--   For simplicity, the type signatures in the examples below monomorphise
--   the functions to use <a>SolrQuery</a> (and therefore <a>SolrExpr</a>,
--   due to the functional dependency).
class Solr expr query | query -> expr, expr -> query

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>int</a> 5)
--   </pre>
int :: Solr expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" Solr.<a>true</a>
--   </pre>
true :: Solr expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" Solr.<a>false</a>
--   </pre>
false :: Solr expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" ("bar" :: Solr.<a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: Solr expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>wild</a> "b?r")
--   </pre>
wild :: Solr expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>regex</a> "[mb]oat")
--   </pre>
regex :: Solr expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", Solr.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (["bar", "baz"] :: Solr.<a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Solr expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (Solr expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>incl</a> (Solr.<a>int</a> 5) `Solr.to` Solr.<a>excl</a> (Solr.<a>int</a> 10))
--   </pre>
to :: (Solr expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   boost :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (Solr expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   </pre>
field :: Solr expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.and` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
and :: Solr expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.or` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
or :: Solr expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.not` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
not :: Solr expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>score</a> (Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")) 3.5
--   </pre>
score :: Solr expr query => query -> Float -> query

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: Solr expr query => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>gt</a> (Solr.<a>int</a> 5))
--   </pre>
gt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>gte</a> (Solr.<a>int</a> 5))
--   </pre>
gte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>lt</a> (Solr.<a>int</a> 5))
--   </pre>
lt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>lte</a> (Solr.<a>int</a> 5))
--   </pre>
lte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: Solr expr query => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: Solr expr query => expr a -> Boundary (expr a)
star :: Solr expr query => Boundary (expr a)


-- | Solr query construction and compilation. You may prefer to import
--   <a>Solr.Query.Qualified</a> instead, which does not contain any
--   operators.
module Solr.Query

-- | A Solr query.
data SolrQuery

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Solr expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Solr expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Solr expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Solr expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: Solr expr query => query -> Float -> query

-- | A Solr expression.
data SolrExpr (t :: SolrType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Solr expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Solr expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Solr expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: Solr expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Solr expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Solr expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Solr expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (Solr expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: Solr expr query => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (Solr expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (Solr expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>. Because the
--   underlying expressions are correct by consutruction, this function is
--   total.
compileSolrQuery :: SolrQuery -> ByteString
instance GHC.Num.Num (Solr.Query.SolrExpr 'Solr.Type.TInt)
instance Data.String.IsString (Solr.Query.SolrExpr 'Solr.Type.TWord)
instance GHC.Exts.IsList (Solr.Query.SolrExpr 'Solr.Type.TPhrase)
instance Solr.Class.Solr Solr.Query.SolrExpr Solr.Query.SolrQuery


-- | This module is an alternative to <a>Solr.Query</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Query.Qualified as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<tt>~:</tt>)  = <a>fuzz</a>
--   (<tt>^:</tt>)  = <a>boost</a>
--   (<tt>=:</tt>)  = <a>field</a>
--   (<tt>&amp;&amp;:</tt>) = <a>and</a>
--   (<tt>||:</tt>) = <a>or</a>
--   (<tt>-:</tt>)  = <a>not</a>
--   (<tt>^=:</tt>) = <a>score</a>
--   </pre>
module Solr.Query.Qualified

-- | A Solr query.
data SolrQuery

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   </pre>
field :: Solr expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.and` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
and :: Solr expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.or` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
or :: Solr expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.not` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
not :: Solr expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>score</a> (Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")) 3.5
--   </pre>
score :: Solr expr query => query -> Float -> query

-- | A Solr expression.
data SolrExpr (t :: SolrType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>int</a> 5)
--   </pre>
int :: Solr expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" Solr.<a>true</a>
--   </pre>
true :: Solr expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" Solr.<a>false</a>
--   </pre>
false :: Solr expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" ("bar" :: Solr.<a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: Solr expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>wild</a> "b?r")
--   </pre>
wild :: Solr expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>regex</a> "[mb]oat")
--   </pre>
regex :: Solr expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", Solr.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (["bar", "baz"] :: Solr.<a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Solr expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (Solr expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: Solr expr query => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>incl</a> (Solr.<a>int</a> 5) `Solr.to` Solr.<a>excl</a> (Solr.<a>int</a> 10))
--   </pre>
to :: (Solr expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>gt</a> (Solr.<a>int</a> 5))
--   </pre>
gt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>gte</a> (Solr.<a>int</a> 5))
--   </pre>
gte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>lt</a> (Solr.<a>int</a> 5))
--   </pre>
lt :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>lte</a> (Solr.<a>int</a> 5))
--   </pre>
lte :: (Solr expr query, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   boost :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Solr.<a>SolrQuery</a>
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (Solr expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>. Because the
--   underlying expressions are correct by consutruction, this function is
--   total.
compileSolrQuery :: SolrQuery -> ByteString
