-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package solr-query
@version 0.2.2.0

module Solr.Type

-- | A Solr type.
data SolrType
TInt :: SolrType
TBool :: SolrType
TWord :: SolrType
TFuzzyWord :: SolrType
TBoostedWord :: SolrType
TWild :: SolrType
TRegex :: SolrType
TPhrase :: SolrType
TFuzzyPhrase :: SolrType
TBoostedPhrase :: SolrType
TRange :: SolrType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class FuzzableType (a :: SolrType) where type family TFuzzed a :: SolrType

-- | <pre>
--   type TFuzzed TWord = TFuzzyWord
--   </pre>

-- | <pre>
--   type TFuzzed TPhrase = TFuzzyPhrase
--   </pre>

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class BoostableType (a :: SolrType) where type family TBoosted a :: SolrType

-- | <pre>
--   type TBoosted TWord = TBoostedWord
--   </pre>

-- | <pre>
--   type TBoosted TPhrase = TBoostedPhrase
--   </pre>

-- | Types that can appear in a range expression.
class PrimType (a :: SolrType)
instance Solr.Type.FuzzableType 'Solr.Type.TWord
instance Solr.Type.FuzzableType 'Solr.Type.TPhrase
instance Solr.Type.BoostableType 'Solr.Type.TWord
instance Solr.Type.BoostableType 'Solr.Type.TPhrase
instance Solr.Type.PrimType 'Solr.Type.TWord
instance Solr.Type.PrimType 'Solr.Type.TInt


-- | This module defines the finally tagless Solr DSL. This style admits
--   multiple interpreters, one of which (lazy <a>ByteString</a>s) is
--   provided by this library in the <a>Solr.Query</a> module.
--   
--   Users should instead import either <a>Solr.Query</a> or
--   <a>Solr.Qualified.Query</a>.
module Solr.Class

-- | Solr expression.
class SolrExprSYM (expr :: SolrType -> *)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: SolrExprSYM expr => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Solr query.
class SolrExprSYM expr => SolrQuerySYM expr query | query -> expr where data family LocalParams query :: *

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a> 'False
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query False -> Float -> query False

-- | Add local parameters to a query. A query can only have one set of
--   local parameters, hence the boolean tag that tracks whether or not
--   they've been added.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'True
--   query = <a>localParams</a> (<a>paramDefaultField</a> "foo") (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
localParams :: SolrQuerySYM expr query => LocalParams query -> query False -> query True

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query is allowed, but will require a type
--   annotation.
star :: SolrExprSYM expr => Boundary (expr a)


-- | This module is an alternative to <a>Solr.Class</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Class as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<a>~:</a>)  = <a>fuzz</a>
--   (<a>^:</a>)  = <a>boost</a>
--   (<a>=:</a>)  = <a>field</a>
--   (<a>&amp;&amp;:</a>) = <a>and</a>
--   (<a>||:</a>) = <a>or</a>
--   (<a>-:</a>)  = <a>not</a>
--   (<a>^=:</a>) = <a>score</a>
--   </pre>
module Solr.Qualified.Class

-- | Solr expression.
class SolrExprSYM (expr :: SolrType -> *)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>int</a> 5)
--   </pre>
int :: SolrExprSYM expr => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" Solr.<a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" Solr.<a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" ("bar" :: Solr.<a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>wild</a> "b?r")
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>regex</a> "[mb]oat")
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", Solr.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (["bar", "baz"] :: Solr.<a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>incl</a> (Solr.<a>int</a> 5) `Solr.to` Solr.<a>excl</a> (Solr.<a>int</a> 10))
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   boost :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Solr query.
class SolrExprSYM expr => SolrQuerySYM expr query | query -> expr

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>defaultField</a> (Solr.<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   </pre>
field :: SolrQuerySYM expr query => Text -> expr a -> query False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.and` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
and :: SolrQuerySYM expr query => query False -> query False -> query False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.or` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
or :: SolrQuerySYM expr query => query False -> query False -> query False

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.not` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
not :: SolrQuerySYM expr query => query False -> query False -> query False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>score</a> (Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")) 3.5
--   </pre>
score :: SolrQuerySYM expr query => query False -> Float -> query False

-- | Add local parameters to a query. A query can only have one set of
--   local parameters, hence the boolean tag that tracks whether or not
--   they've been added.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: Solr.<a>SolrQuery</a> 'True
--   query = Solr.<a>localParams</a> (Solr.<a>paramDefaultField</a> "foo") (Solr.<a>defaultField</a> (Solr.<a>word</a> "bar"))
--   </pre>
localParams :: SolrQuerySYM expr query => LocalParams query -> query False -> query True

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>gt</a> (Solr.<a>int</a> 5))
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>gte</a> (Solr.<a>int</a> 5))
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>lt</a> (Solr.<a>int</a> 5))
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>lte</a> (Solr.<a>int</a> 5))
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: SolrExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query is allowed, but will require a type
--   annotation.
star :: SolrExprSYM expr => Boundary (expr a)


-- | Solr query construction and compilation. You may prefer to import
--   <a>Solr.Qualified.Query</a> instead, which does not export any
--   operators.
module Solr.Query

-- | A Solr query. The boolean phantom type tracks whether or not this
--   query has local params or not.
--   
--   You may ignore the <tt>data <a>LocalParams</a> <a>SolrQuery</a></tt>
--   instance below; the data constructor <tt>SolrQueryParams</tt> is not
--   exported, but shows up in the Haddocks anyway.
data SolrQuery :: Bool -> *

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: <a>SolrQuery</a> 'False
--   query = <a>defaultField</a> (<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: SolrQuerySYM expr query => Text -> expr a -> query False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: SolrQuerySYM expr query => query False -> query False -> query False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: SolrQuerySYM expr query => query False -> Float -> query False

-- | Add local parameters to a query. A query can only have one set of
--   local parameters, hence the boolean tag that tracks whether or not
--   they've been added.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'True
--   query = <a>localParams</a> (<a>paramDefaultField</a> "foo") (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
localParams :: SolrQuerySYM expr query => LocalParams query -> query False -> query True

-- | A Solr expression.
data SolrExpr (t :: SolrType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: SolrExprSYM expr => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> ("bar" :: <a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>SolrQuery</a> 'False
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Set the <tt>'df'</tt> local parameter.
--   
--   Example:
--   
--   <pre>
--   -- {!df=foo}bar
--   query :: <a>SolrQuery</a> 'True
--   query = <a>localParams</a> (<a>paramDefaultField</a> "foo") (<a>defaultField</a> (<a>word</a> "bar"))
--   </pre>
paramDefaultField :: Text -> LocalParams SolrQuery

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>.
--   
--   Example:
--   
--   <pre>
--   λ let params = <a>paramDefaultField</a> "body"
--   λ let query = "foo" =: <a>phrase</a> ["bar", "baz"] <a>~:</a> 5 <a>&amp;&amp;:</a> <a>defaultField</a> (<a>regex</a> "wh?at")
--   λ <a>compileSolrQuery</a> (<a>localParams</a> params query)
--   "{!df=body}(foo:"bar baz"~5 AND <i>wh?t</i>)"
--   </pre>
compileSolrQuery :: SolrQuery a -> ByteString
instance GHC.Num.Num (Solr.Query.SolrExpr 'Solr.Type.TInt)
instance Data.String.IsString (Solr.Query.SolrExpr 'Solr.Type.TWord)
instance GHC.Exts.IsList (Solr.Query.SolrExpr 'Solr.Type.TPhrase)
instance Solr.Class.SolrExprSYM Solr.Query.SolrExpr
instance Data.Semigroup.Semigroup (Solr.Query.SolrQuery 'GHC.Types.False)
instance GHC.Base.Monoid (Solr.Query.SolrQuery 'GHC.Types.False)
instance Solr.Class.SolrQuerySYM Solr.Query.SolrExpr Solr.Query.SolrQuery
instance Data.Semigroup.Semigroup (Solr.Class.LocalParams Solr.Query.SolrQuery)


-- | This module is an alternative to <a>Solr.Query</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Solr.Qualified.Query as Solr
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<a>~:</a>)  = <a>fuzz</a>
--   (<a>^:</a>)  = <a>boost</a>
--   (<a>=:</a>)  = <a>field</a>
--   (<a>&amp;&amp;:</a>) = <a>and</a>
--   (<a>||:</a>) = <a>or</a>
--   (<a>-:</a>)  = <a>not</a>
--   (<a>^=:</a>) = <a>score</a>
--   </pre>
module Solr.Qualified.Query

-- | A Solr query. The boolean phantom type tracks whether or not this
--   query has local params or not.
--   
--   You may ignore the <tt>data <a>LocalParams</a> <a>SolrQuery</a></tt>
--   instance below; the data constructor <tt>SolrQueryParams</tt> is not
--   exported, but shows up in the Haddocks anyway.
data SolrQuery :: Bool -> *

-- | A default field query.
--   
--   Example:
--   
--   <pre>
--   -- foo
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>defaultField</a> (Solr.<a>word</a> "foo")
--   </pre>
defaultField :: SolrQuerySYM expr query => expr a -> query False

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   </pre>
field :: SolrQuerySYM expr query => Text -> expr a -> query False

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.and` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
and :: SolrQuerySYM expr query => query False -> query False -> query False

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.or` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
or :: SolrQuerySYM expr query => query False -> query False -> query False

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar") `Solr.not` Solr.<a>field</a> "baz" (Solr.<a>word</a> "qux")
--   </pre>
not :: SolrQuerySYM expr query => query False -> query False -> query False

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Solr query (I haven't tested),
--   but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>score</a> (Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")) 3.5
--   </pre>
score :: SolrQuerySYM expr query => query False -> Float -> query False

-- | A Solr expression.
data SolrExpr (t :: SolrType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>SolrExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>int</a> 5)
--   </pre>
int :: SolrExprSYM expr => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" Solr.<a>true</a>
--   </pre>
true :: SolrExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" Solr.<a>false</a>
--   </pre>
false :: SolrExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>SolrExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" ("bar" :: Solr.<a>SolrExpr</a> <a>TWord</a>)
--   </pre>
word :: SolrExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>wild</a> "b?r")
--   </pre>
wild :: SolrExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>regex</a> "[mb]oat")
--   </pre>
regex :: SolrExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>SolrExpr</a> <a>TPhrase</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", Solr.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Solr query)
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (["bar", "baz"] :: Solr.<a>SolrExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: SolrExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>SolrExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzz</a> (Solr.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (SolrExprSYM expr, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: SolrExprSYM expr => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TWord</a>) -&gt; <a>SolrExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>SolrExpr</a> <a>TInt</a>)  -&gt; <a>SolrExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>incl</a> (Solr.<a>int</a> 5) `Solr.to` Solr.<a>excl</a> (Solr.<a>int</a> 10))
--   </pre>
to :: (SolrExprSYM expr, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>gt</a> (Solr.<a>int</a> 5))
--   </pre>
gt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>gte</a> (Solr.<a>int</a> 5))
--   </pre>
gte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>lt</a> (Solr.<a>int</a> 5))
--   </pre>
lt :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>lte</a> (Solr.<a>int</a> 5))
--   </pre>
lte :: (SolrExprSYM expr, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>SolrExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedWord</a>
--   boost :: <a>SolrExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>SolrExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Solr.<a>SolrQuery</a> 'False
--   query = Solr.<a>field</a> "foo" (Solr.<a>boost</a> (Solr.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (SolrExprSYM expr, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>SolrQuery</a> to a lazy <a>ByteString</a>.
--   
--   Example:
--   
--   <pre>
--   λ let params = <a>paramDefaultField</a> "body"
--   λ let query = "foo" =: <a>phrase</a> ["bar", "baz"] <a>~:</a> 5 <a>&amp;&amp;:</a> <a>defaultField</a> (<a>regex</a> "wh?at")
--   λ <a>compileSolrQuery</a> (<a>localParams</a> params query)
--   "{!df=body}(foo:"bar baz"~5 AND <i>wh?t</i>)"
--   </pre>
compileSolrQuery :: SolrQuery a -> ByteString
