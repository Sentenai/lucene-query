<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Expr</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span>
</span><a name="line-2"></a><span>  </span><span class="hs-special">(</span><span> </span><span class="hs-comment">-- * Solr expression language</span><span>
</span><a name="line-3"></a><span>    </span><a href="Solr.Expr.Class.html#ExprSYM"><span class="hs-identifier hs-type">ExprSYM</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-4"></a><span>    </span><span class="hs-comment">-- * Derived combinators</span><span>
</span><a name="line-5"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#fuzzy"><span class="hs-identifier hs-var">fuzzy</span></a><span>
</span><a name="line-6"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#gt"><span class="hs-identifier hs-var">gt</span></a><span>
</span><a name="line-7"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#gte"><span class="hs-identifier hs-var">gte</span></a><span>
</span><a name="line-8"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#lt"><span class="hs-identifier hs-var">lt</span></a><span>
</span><a name="line-9"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#lte"><span class="hs-identifier hs-var">lte</span></a><span>
</span><a name="line-10"></a><span>    </span><span class="hs-comment">-- * Range expression helpers</span><span>
</span><a name="line-11"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#Boundary"><span class="hs-identifier hs-type">Boundary</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-12"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#incl"><span class="hs-identifier hs-var">incl</span></a><span>
</span><a name="line-13"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#excl"><span class="hs-identifier hs-var">excl</span></a><span>
</span><a name="line-14"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#star"><span class="hs-identifier hs-var">star</span></a><span>
</span><a name="line-15"></a><span>    </span><span class="hs-comment">-- * Named operators</span><span>
</span><a name="line-16"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#fuzz"><span class="hs-identifier hs-var">fuzz</span></a><span>
</span><a name="line-17"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Class.html#boost"><span class="hs-identifier hs-var">boost</span></a><span>
</span><a name="line-18"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-19"></a><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span> </span><a href="Solr.Type.html"><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span></a><span>
</span><a name="line-21"></a><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Text</span><span class="hs-special">)</span><span>
</span><a name="line-23"></a><span>
</span><a name="line-24"></a><span>
</span><a name="line-25"></a><span class="hs-comment">-- $setup</span><span>
</span><a name="line-26"></a><span class="hs-comment">-- &gt;&gt;&gt; import Solr.Query</span><span>
</span><a name="line-27"></a><span>
</span><a name="line-28"></a><span>
</span><a name="line-29"></a><span class="hs-comment">-- | Solr expression.</span><span>
</span><a name="line-30"></a><span class="hs-keyword">class</span><span> </span><a name="ExprSYM"><a href="Solr.Expr.Class.html#ExprSYM"><span class="hs-identifier">ExprSYM</span></a></a><span> </span><a name="local-1627423453"><a href="#local-1627423453"><span class="hs-identifier">expr</span></a></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-31"></a><span>  </span><span class="hs-comment">-- | A @num@ expression.</span><span>
</span><a name="line-32"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-33"></a><span>  </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><a name="line-34"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-35"></a><span>  </span><span class="hs-comment">-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: num 5 :: Query Expr)</span><span>
</span><a name="line-36"></a><span>  </span><span class="hs-comment">-- &quot;q=foo:5.0&quot;</span><span>
</span><a name="line-37"></a><span>  </span><span class="hs-identifier">num</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Float</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-1627423453"><span class="hs-identifier hs-type">expr</span></a><span> </span><span class="hs-char">'TNum

  -- | A @true@ expression.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: true :: Query Expr)
  -- &quot;q=foo:true&quot;
  true :: expr 'TBool

  -- | A @false@ expression.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: false :: Query Expr)
  -- &quot;q=foo:false&quot;
  false :: expr 'TBool

  -- | A single word. Must /not/ contain any spaces, wildcard characters
  -- (@\'?\'@ and @\'*\'@), or tildes (@\'~\'@), though this is not enforced by
  -- the type system.
  --
  -- Note that sometimes you may use the 'Data.String.IsString' instance for
  -- 'Solr.Query.Expr' 'TWord', but usually an explicit type signature
  -- will be required (at the interpretation site or earlier).
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: word &quot;bar&quot; :: Query Expr)
  -- &quot;q=foo:bar&quot;
  word :: Text -&gt; expr 'TWord

  -- | A single word that may contain wildcard characters (@\'?\'@ and @\'*\'@),
  -- although the meaning of consecutive @\'*\'@s is probably ill-defined. Must
  -- also /not/ contain any spaces or tildes (@\'~\'@), though this is not
  -- enforced by the type system.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: wild &quot;b?r&quot; :: Query Expr)
  -- &quot;q=foo:b?r&quot;
  wild :: Text -&gt; expr 'TWild

  -- | A regular expression, whose syntax is described by
  -- &lt;http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true&gt;.
  --
  -- Note that the leading and trailing @\'/\'@ must be omitted. The regex
  -- innards are not type checked in any way.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: regex &quot;[mb]oat&quot; :: Query Expr)
  -- &quot;q=foo:/[mb]oat/&quot;
  regex :: Text -&gt; expr 'TRegex

  -- | A phrase, composed of multiple (non-fuzzy) words, none of which may
  -- contain wildcard characters. Both of these properties are enforced by the
  -- type system, as long as the words themselves adhere to the 'word' contract.
  -- The list should not be empty.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: phrase [&quot;bar&quot;, &quot;baz&quot;] :: Query Expr)
  -- &quot;q=foo:\&quot;bar baz\&quot;&quot;
  phrase :: [expr 'TWord] -&gt; expr 'TPhrase

  -- | The @\'~\'@ operator, which fuzzes its argument (either a word or phrase)
  -- by a numeric amount.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: word &quot;bar&quot; ~: 1 :: Query Expr)
  -- &quot;q=foo:bar~1&quot;
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: phrase [&quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] ~: 10 :: Query Expr)
  -- &quot;q=foo:\&quot;bar baz qux\&quot;~10&quot;
  (~:) :: Fuzzable a =&gt; expr a -&gt; Int -&gt; expr ('TFuzzed a)
  infix 6 ~:

  -- | A range expression.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: incl (num 5) `to` excl (num 10) :: Query Expr)
  -- &quot;q=foo:[5.0 TO 10.0}&quot;
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: excl (word &quot;bar&quot;) `to` star :: Query Expr)
  -- &quot;q=foo:{bar TO *]&quot;
  --
  -- -- Note the explicit type signature required for @[* TO *]@ queries
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: star `to` (star :: Boundary (Expr 'TNum)) :: Query Expr)
  -- &quot;q=foo:[* TO *]&quot;
  to :: Rangeable a =&gt; Boundary (expr a) -&gt; Boundary (expr a) -&gt; expr ('TRanged a)
  infix 6 `to`

  -- | The @\'^\'@ operator, which boosts its argument.
  --
  -- ==== __Examples__
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: word &quot;bar&quot; ^: 3.5 :: Query Expr)
  -- &quot;q=foo:bar^3.5&quot;
  --
  -- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: phrase [&quot;bar&quot;, &quot;baz&quot;] ^: 3.5 :: Query Expr)
  -- &quot;q=foo:\&quot;bar baz\&quot;^3.5&quot;
  (^:) :: Boostable a =&gt; expr a -&gt; Float -&gt; expr ('TBoosted a)
  infix 6 ^:

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
-- Solr @\'~\'@ operator without an integer added.
--
-- @
-- 'fuzzy' e = e '~:' 2
-- @
--
-- ==== __Examples__
--
-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: fuzzy &quot;bar&quot; :: Query Expr)
-- &quot;q=foo:bar~2&quot;
fuzzy :: ExprSYM expr =&gt; expr 'TWord -&gt; expr ('TFuzzed 'TWord)
fuzzy e = e ~: 2

-- | Short-hand for a greater-than range query.
--
-- @
-- 'gt' e = 'excl' e \`to\` 'star'
-- @
--
-- ==== __Examples__
--
-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: gt (num 5) :: Query Expr)
-- &quot;q=foo:{5.0 TO *]&quot;
gt :: (ExprSYM expr, Rangeable a) =&gt; expr a -&gt; expr ('TRanged a)
gt e = excl e `to` star

-- | Short-hand for a greater-than-or-equal-to range query.
--
-- @
-- 'gte' e = 'incl' e \`to\` 'star'
-- @
--
-- ==== __Examples__
--
-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: gte (num 5) :: Query Expr)
-- &quot;q=foo:[5.0 TO *]&quot;
gte :: (ExprSYM expr, Rangeable a) =&gt; expr a -&gt; expr ('TRanged a)
gte e = incl e `to` star

-- | Short-hand for a less-than range query.
--
-- @
--  'lt' e = 'star' \`to\` 'excl' e
-- @
--
-- ==== __Examples__
--
-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: lt (num 5) :: Query Expr)
-- &quot;q=foo:[* TO 5.0}&quot;
lt :: (ExprSYM expr, Rangeable a) =&gt; expr a -&gt; expr ('TRanged a)
lt e = star `to` excl e

-- | Short-hand for a less-than-or-equal-to range query.
--
-- @
-- 'lte' e = 'star' \`to\` 'incl' e
-- @
--
-- ==== __Examples__
--
-- &gt;&gt;&gt; compile [] (&quot;foo&quot; =: lte (num 5) :: Query Expr)
-- &quot;q=foo:[* TO 5.0]&quot;
lte :: (ExprSYM expr, Rangeable a) =&gt; expr a -&gt; expr ('TRanged a)
lte e = star `to` incl e


-- | An inclusive or exclusive expression for use in a range query, built with
-- either 'incl', 'excl', or 'star'.
--
-- The constructors are exported for use in interpreters.
data Boundary a
  = Inclusive a
  | Exclusive a
  | Star
  deriving (Eq, Functor, Show)

-- | Mark an expression as inclusive, for use in a range query.
incl :: ExprSYM expr =&gt; expr a -&gt; Boundary (expr a)
incl = Inclusive

-- | Mark an expression as exclusive, for use in a range query.
excl :: ExprSYM expr =&gt; expr a -&gt; Boundary (expr a)
excl = Exclusive

-- | @\'*\'@ operator, signifying the minimum or maximun bound of a range. A
-- @[* TO *]@ query will require a type annotation.
star :: ExprSYM expr =&gt; Boundary (expr a)
star = Star


-- | Named version of ('~:').
fuzz :: (ExprSYM expr, Fuzzable a) =&gt; expr a -&gt; Int -&gt; expr ('TFuzzed a)
fuzz = (~:)

-- | Named version of ('^:').
boost :: (ExprSYM expr, Boostable a) =&gt; expr a -&gt; Float -&gt; expr ('TBoosted a)
boost = (^:)
</span></pre></body></html>