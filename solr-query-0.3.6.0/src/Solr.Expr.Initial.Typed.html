<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Expr</span><span class="hs-operator">.</span><span class="hs-identifier">Initial</span><span class="hs-operator">.</span><span class="hs-identifier">Typed</span><span>
</span><a name="line-2"></a><span>  </span><span class="hs-special">(</span><span> </span><span class="hs-comment">-- * Expression type</span><span>
</span><a name="line-3"></a><span>    </span><a href="Solr.Expr.Initial.Typed.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-4"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Initial.Typed.html#typeCheck"><span class="hs-identifier hs-var">typeCheck</span></a><span>
</span><a name="line-5"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Solr.Expr.Initial.Typed.html#reinterpret"><span class="hs-identifier hs-var">reinterpret</span></a><span>
</span><a name="line-6"></a><span>    </span><span class="hs-comment">-- * Re-exports</span><span>
</span><a name="line-7"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Expr</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span>
</span><a name="line-8"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-9"></a><span>
</span><a name="line-10"></a><span class="hs-keyword">import</span><span> </span><a href="Solr.Expr.Class.html"><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Expr</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span></a><span>
</span><a name="line-11"></a><span class="hs-keyword">import</span><span> </span><a href="Solr.Type.html"><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span></a><span>
</span><a name="line-12"></a><span>
</span><a name="line-13"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Solr.Expr.Initial.Untyped.html"><span class="hs-identifier">Solr</span><span class="hs-operator">.</span><span class="hs-identifier">Expr</span><span class="hs-operator">.</span><span class="hs-identifier">Initial</span><span class="hs-operator">.</span><span class="hs-identifier">Untyped</span></a><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">Untyped</span><span>
</span><a name="line-14"></a><span>
</span><a name="line-15"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">forM</span><span class="hs-special">)</span><span>
</span><a name="line-16"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span>     </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Text</span><span class="hs-special">)</span><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span>
</span><a name="line-19"></a><span class="hs-comment">-- | A typed, initially-encoded Solr expression.</span><span>
</span><a name="line-20"></a><span class="hs-keyword">data</span><span> </span><a name="Expr"><a href="Solr.Expr.Initial.Typed.html#Expr"><span class="hs-identifier">Expr</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Solr.Type.html#SolrType"><span class="hs-identifier hs-type">SolrType</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator hs-type">*</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-21"></a><span>  </span><a name="ENum"><a href="Solr.Expr.Initial.Typed.html#ENum"><span class="hs-identifier">ENum</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Float</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Solr.Expr.Initial.Typed.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-char">'TNum
  ETrue   :: Expr 'TBool
  EFalse  :: Expr 'TBool
  EWord   :: Text -&gt; Expr 'TWord
  EWild   :: Text -&gt; Expr 'TWild
  ERegex  :: Text -&gt; Expr 'TRegex
  EPhrase :: [Expr 'TWord] -&gt; Expr 'TPhrase
  EFuzz   :: Fuzzable a =&gt; Expr a -&gt; Int -&gt; Expr ('TFuzzed a)
  ETo     :: Rangeable a =&gt; Boundary (Expr a) -&gt; Boundary (Expr a) -&gt; Expr ('TRanged a)
  EBoost  :: Boostable a =&gt; Expr a -&gt; Float -&gt; Expr ('TBoosted a)

instance ExprSYM Expr where
  num    = ENum
  true   = ETrue
  false  = EFalse
  word   = EWord
  wild   = EWild
  regex  = ERegex
  phrase = EPhrase
  (~:)   = EFuzz
  to     = ETo
  (^:)   = EBoost


-- | Existential wrapper around 'Expr'.
data SomeExpr where
  SomeExpr :: Expr ty -&gt; SomeExpr

-- | Type check an untyped Solr expression. Note the untyped 'Untyped.Expr' on
-- the way in is not the same as the typed 'Expr' on the way out.
--
-- @
-- 'typeCheck' u k =
--   case 'typeCheck'' u of
--     Nothing -&gt; k Nothing
--     Just ('SomeExpr' e) -&gt; k (Just e)
-- @
typeCheck :: Untyped.Expr a -&gt; (forall ty. Maybe (Expr ty) -&gt; r) -&gt; r
typeCheck u k =
  case typeCheck' u of
    Nothing -&gt; k Nothing
    Just (SomeExpr e) -&gt; k (Just e)

-- | Like 'typeCheck', but return an existential type rather than use
-- rank-2 continuation passing style, if you prefer.
typeCheck' :: Untyped.Expr a -&gt; Maybe SomeExpr
typeCheck' u0 =
  case u0 of
    Untyped.ENum n   -&gt; pure (SomeExpr (ENum n))
    Untyped.ETrue    -&gt; pure (SomeExpr ETrue)
    Untyped.EFalse   -&gt; pure (SomeExpr EFalse)
    Untyped.EWord s  -&gt; pure (SomeExpr (EWord s))
    Untyped.EWild s  -&gt; pure (SomeExpr (EWild s))
    Untyped.ERegex s -&gt; pure (SomeExpr (ERegex s))

    Untyped.EPhrase ss0 -&gt; do
      es &lt;- forM ss0 (\s -&gt; do
                       SomeExpr e@(EWord _) &lt;- typeCheck' s
                       pure e)
      pure (SomeExpr (EPhrase es))

    Untyped.EFuzz u n -&gt; do
      SomeExpr e &lt;- typeCheck' u
      case e of
        EWord _   -&gt; pure (SomeExpr (EFuzz e n))
        EPhrase _ -&gt; pure (SomeExpr (EFuzz e n))
        _         -&gt; Nothing

    -- FIXME: Hm, when type checking a [* TO *], do I really have to just pick a
    -- type here? Seems wrong...
    Untyped.ETo Star Star -&gt;
      pure (SomeExpr (ETo (Star :: Boundary (Expr 'TNum)) Star))

    Untyped.ETo Star (Inclusive u)            -&gt; starLeft  Inclusive u
    Untyped.ETo Star (Exclusive u)            -&gt; starLeft  Exclusive u
    Untyped.ETo (Inclusive u) Star            -&gt; starRight Inclusive u
    Untyped.ETo (Exclusive u) Star            -&gt; starRight Exclusive u

    Untyped.ETo (Inclusive u1) (Inclusive u2) -&gt; noStar Inclusive Inclusive u1 u2
    Untyped.ETo (Inclusive u1) (Exclusive u2) -&gt; noStar Inclusive Exclusive u1 u2
    Untyped.ETo (Exclusive u1) (Inclusive u2) -&gt; noStar Exclusive Inclusive u1 u2
    Untyped.ETo (Exclusive u1) (Exclusive u2) -&gt; noStar Exclusive Exclusive u1 u2

    Untyped.EBoost u n -&gt; do
      SomeExpr e &lt;- typeCheck' u
      case e of
        EWord _   -&gt; pure (SomeExpr (EBoost e n))
        EPhrase _ -&gt; pure (SomeExpr (EBoost e n))
        _         -&gt; Nothing

-- Type check a *-to-EXPR
starLeft :: (forall x. x -&gt; Boundary x) -&gt; Untyped.Expr a -&gt; Maybe SomeExpr
starLeft con u = do
  SomeExpr e &lt;- typeCheck' u
  case e of
    ENum _  -&gt; pure (SomeExpr (ETo Star (con e)))
    EWord _ -&gt; pure (SomeExpr (ETo Star (con e)))
    _       -&gt; Nothing

-- Type check a EXPR-to-*
starRight :: (forall x. x -&gt; Boundary x) -&gt; Untyped.Expr a -&gt; Maybe SomeExpr
starRight con u = do
  SomeExpr e &lt;- typeCheck' u
  case e of
    ENum _  -&gt; pure (SomeExpr (ETo (con e) Star))
    EWord _ -&gt; pure (SomeExpr (ETo (con e) Star))
    _       -&gt; Nothing

-- Type check a EXPR-to-EXPR
noStar
  :: (forall x. x -&gt; Boundary x)
  -&gt; (forall x. x -&gt; Boundary x)
  -&gt; Untyped.Expr a
  -&gt; Untyped.Expr a
  -&gt; Maybe SomeExpr
noStar con1 con2 u1 u2 = do
  SomeExpr e1 &lt;- typeCheck' u1
  SomeExpr e2 &lt;- typeCheck' u2
  case (e1, e2) of
    (ENum _,  ENum _)  -&gt; pure (SomeExpr (ETo (con1 e1) (con2 e2)))
    (EWord _, EWord _) -&gt; pure (SomeExpr (ETo (con1 e1) (con2 e2)))
    _                  -&gt; Nothing


-- | Reinterpret a Solr expression.
reinterpret :: ExprSYM expr =&gt; Expr ty -&gt; expr ty
reinterpret = \case
  ENum n     -&gt; num n
  ETrue      -&gt; true
  EFalse     -&gt; false
  EWord s    -&gt; word s
  EWild s    -&gt; wild s
  ERegex s   -&gt; regex s
  EPhrase es -&gt; phrase (map reinterpret es)
  EFuzz e n  -&gt; reinterpret e ~: n
  ETo e1 e2  -&gt; fmap reinterpret e1 `to` fmap reinterpret e2
  EBoost e n -&gt; reinterpret e ^: n
</span></pre></body></html>