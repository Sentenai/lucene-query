-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solr query EDSL
--   
--   Solr query EDSL
@package solr-query
@version 0.3.6.0

module Solr.Type
data SolrType
TNum :: SolrType
TBool :: SolrType
TWord :: SolrType
TWild :: SolrType
TRegex :: SolrType
TPhrase :: SolrType
TFuzzed :: SolrType -> SolrType
TBoosted :: SolrType -> SolrType
TRanged :: SolrType -> SolrType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class Fuzzable (ty :: SolrType)

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class Boostable (ty :: SolrType)

-- | Types that can appear in a <tt><tt>TO</tt></tt> range expression.
class Rangeable (ty :: SolrType)
instance Solr.Type.Fuzzable 'Solr.Type.TWord
instance Solr.Type.Fuzzable 'Solr.Type.TPhrase
instance Solr.Type.Boostable 'Solr.Type.TWord
instance Solr.Type.Boostable 'Solr.Type.TPhrase
instance Solr.Type.Rangeable 'Solr.Type.TNum
instance Solr.Type.Rangeable 'Solr.Type.TWord

module Solr.Param.Internal
data Param query
[ParamCache] :: HasParamCache query => Bool -> Param query
[ParamCost] :: HasParamCost query => Int -> Param query
[ParamDefaultField] :: HasParamDefaultField query => Text -> Param query
[ParamOpAnd] :: HasParamOp query => Param query
[ParamOpOr] :: HasParamOp query => Param query
[ParamRows] :: HasParamRows query => Int -> Param query
[ParamStart] :: HasParamStart query => Int -> Param query

-- | The <tt>'cache'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: FilterQuery Expr
--   
--   &gt;&gt;&gt; FilterQuery.compile [paramCache False] query
--   "fq={!cache=false}foo:bar"
--   </pre>
paramCache :: HasParamCache query => Bool -> Param query

-- | The <tt>'cost'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: FilterQuery Expr
--   
--   &gt;&gt;&gt; FilterQuery.compile [paramCost 5] query
--   "fq={!cost=5}foo:bar"
--   </pre>
paramCost :: HasParamCost query => Int -> Param query

-- | The <tt>'df'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramDefaultField "foo"] query
--   "q={!df=foo}bar"
--   </pre>
paramDefaultField :: HasParamDefaultField query => Text -> Param query

-- | The <tt>'op=AND'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "foo") &lt;&gt; defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramOpAnd] query
--   "q={!q.op=AND}foo bar"
--   </pre>
paramOpAnd :: HasParamOp query => Param query

-- | The <tt>'op=OR'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "foo") &lt;&gt; defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramOpOr] query
--   "q={!q.op=OR}foo bar"
--   </pre>
paramOpOr :: HasParamOp query => Param query

-- | The <tt>'rows'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramRows 5] query
--   "q={!rows=5}foo:bar"
--   </pre>
paramRows :: HasParamRows query => Int -> Param query

-- | The <tt>'start'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramStart 10] query
--   "q={!start=10}foo:bar"
--   </pre>
paramStart :: HasParamStart query => Int -> Param query
class HasParamCache (query :: (SolrType -> *) -> *)
class HasParamCost (query :: (SolrType -> *) -> *)
class HasParamDefaultField (query :: (SolrType -> *) -> *)
class HasParamOp (query :: (SolrType -> *) -> *)
class HasParamRows (query :: (SolrType -> *) -> *)
class HasParamStart (query :: (SolrType -> *) -> *)
instance GHC.Show.Show (Solr.Param.Internal.Param query)


-- | Query parameters.
module Solr.Param
data Param query

-- | The <tt>'cache'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: FilterQuery Expr
--   
--   &gt;&gt;&gt; FilterQuery.compile [paramCache False] query
--   "fq={!cache=false}foo:bar"
--   </pre>
paramCache :: HasParamCache query => Bool -> Param query

-- | The <tt>'cost'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: FilterQuery Expr
--   
--   &gt;&gt;&gt; FilterQuery.compile [paramCost 5] query
--   "fq={!cost=5}foo:bar"
--   </pre>
paramCost :: HasParamCost query => Int -> Param query

-- | The <tt>'df'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramDefaultField "foo"] query
--   "q={!df=foo}bar"
--   </pre>
paramDefaultField :: HasParamDefaultField query => Text -> Param query

-- | The <tt>'op=AND'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "foo") &lt;&gt; defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramOpAnd] query
--   "q={!q.op=AND}foo bar"
--   </pre>
paramOpAnd :: HasParamOp query => Param query

-- | The <tt>'op=OR'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = defaultField (word "foo") &lt;&gt; defaultField (word "bar") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramOpOr] query
--   "q={!q.op=OR}foo bar"
--   </pre>
paramOpOr :: HasParamOp query => Param query

-- | The <tt>'rows'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramRows 5] query
--   "q={!rows=5}foo:bar"
--   </pre>
paramRows :: HasParamRows query => Int -> Param query

-- | The <tt>'start'</tt> local parameter.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: word "bar" :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramStart 10] query
--   "q={!start=10}foo:bar"
--   </pre>
paramStart :: HasParamStart query => Int -> Param query

module Solr.Expr.Class

-- | Solr expression.
class ExprSYM expr

-- | A <tt>num</tt> expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: num 5 :: Query Expr)
--   "q=foo:5.0"
--   </pre>
num :: ExprSYM expr => Float -> expr TNum

-- | A <tt>true</tt> expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: true :: Query Expr)
--   "q=foo:true"
--   </pre>
true :: ExprSYM expr => expr TBool

-- | A <tt>false</tt> expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: false :: Query Expr)
--   "q=foo:false"
--   </pre>
false :: ExprSYM expr => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>Expr</a> <a>TWord</a>, but usually an explicit type signature will
--   be required (at the interpretation site or earlier).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" :: Query Expr)
--   "q=foo:bar"
--   </pre>
word :: ExprSYM expr => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: wild "b?r" :: Query Expr)
--   "q=foo:b?r"
--   </pre>
wild :: ExprSYM expr => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: regex "[mb]oat" :: Query Expr)
--   "q=foo:/[mb]oat/"
--   </pre>
regex :: ExprSYM expr => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: phrase ["bar", "baz"] :: Query Expr)
--   "q=foo:\"bar baz\""
--   </pre>
phrase :: ExprSYM expr => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" ~: 1 :: Query Expr)
--   "q=foo:bar~1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: phrase ["bar", "baz", "qux"] ~: 10 :: Query Expr)
--   "q=foo:\"bar baz qux\"~10"
--   </pre>
(~:) :: (ExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: incl (num 5) `to` excl (num 10) :: Query Expr)
--   "q=foo:[5.0 TO 10.0}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: excl (word "bar") `to` star :: Query Expr)
--   "q=foo:{bar TO *]"
--   </pre>
--   
--   <ul>
--   <li>- Note the explicit type signature required for <tt>[* TO *]</tt>
--   queries &gt;&gt;&gt; compile [] ("foo" =: star <a>to</a> (star ::
--   Boundary (Expr 'TNum)) :: Query Expr) "q=foo:[* TO *]"</li>
--   </ul>
to :: (ExprSYM expr, Rangeable a) => Boundary (expr a) -> Boundary (expr a) -> expr (TRanged a)

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" ^: 3.5 :: Query Expr)
--   "q=foo:bar^3.5"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: phrase ["bar", "baz"] ^: 3.5 :: Query Expr)
--   "q=foo:\"bar baz\"^3.5"
--   </pre>
(^:) :: (ExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Solr <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = e <a>~:</a> 2
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: fuzzy "bar" :: Query Expr)
--   "q=foo:bar~2"
--   </pre>
fuzzy :: ExprSYM expr => expr TWord -> expr (TFuzzed TWord)

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: gt (num 5) :: Query Expr)
--   "q=foo:{5.0 TO *]"
--   </pre>
gt :: (ExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: gte (num 5) :: Query Expr)
--   "q=foo:[5.0 TO *]"
--   </pre>
gte :: (ExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: lt (num 5) :: Query Expr)
--   "q=foo:[* TO 5.0}"
--   </pre>
lt :: (ExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: lte (num 5) :: Query Expr)
--   "q=foo:[* TO 5.0]"
--   </pre>
lte :: (ExprSYM expr, Rangeable a) => expr a -> expr (TRanged a)

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: ExprSYM expr => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: ExprSYM expr => expr a -> Boundary (expr a)

-- | <tt>'*'</tt> operator, signifying the minimum or maximun bound of a
--   range. A <tt>[* TO *]</tt> query will require a type annotation.
star :: ExprSYM expr => Boundary (expr a)

-- | Named version of (<a>~:</a>).
fuzz :: (ExprSYM expr, Fuzzable a) => expr a -> Int -> expr (TFuzzed a)

-- | Named version of (<a>^:</a>).
boost :: (ExprSYM expr, Boostable a) => expr a -> Float -> expr (TBoosted a)
instance GHC.Show.Show a => GHC.Show.Show (Solr.Expr.Class.Boundary a)
instance GHC.Base.Functor Solr.Expr.Class.Boundary
instance GHC.Classes.Eq a => GHC.Classes.Eq (Solr.Expr.Class.Boundary a)

module Solr.Expr.Initial.Untyped

-- | An untyped, initially-encoded Solr expression.
data Expr (ty :: SolrType)
ENum :: Float -> Expr
ETrue :: Expr
EFalse :: Expr
EWord :: Text -> Expr
EWild :: Text -> Expr
ERegex :: Text -> Expr
EPhrase :: [Expr b] -> Expr
EFuzz :: (Expr b) -> Int -> Expr
ETo :: (Boundary (Expr b)) -> (Boundary (Expr b)) -> Expr
EBoost :: (Expr b) -> Float -> Expr
instance GHC.Show.Show (Solr.Expr.Initial.Untyped.Expr ty)
instance GHC.Classes.Eq (Solr.Expr.Initial.Untyped.Expr ty)
instance Solr.Expr.Class.ExprSYM Solr.Expr.Initial.Untyped.Expr

module Solr.Expr.Initial.Typed

-- | A typed, initially-encoded Solr expression.
data Expr :: SolrType -> *
[ENum] :: Float -> Expr TNum
[ETrue] :: Expr TBool
[EFalse] :: Expr TBool
[EWord] :: Text -> Expr TWord
[EWild] :: Text -> Expr TWild
[ERegex] :: Text -> Expr TRegex
[EPhrase] :: [Expr TWord] -> Expr TPhrase
[EFuzz] :: Fuzzable a => Expr a -> Int -> Expr (TFuzzed a)
[ETo] :: Rangeable a => Boundary (Expr a) -> Boundary (Expr a) -> Expr (TRanged a)
[EBoost] :: Boostable a => Expr a -> Float -> Expr (TBoosted a)

-- | Type check an untyped Solr expression. Note the untyped <a>Expr</a> on
--   the way in is not the same as the typed <a>Expr</a> on the way out.
--   
--   <pre>
--   <a>typeCheck</a> u k =
--     case <a>typeCheck'</a> u of
--       Nothing -&gt; k Nothing
--       Just (<a>SomeExpr</a> e) -&gt; k (Just e)
--   </pre>
typeCheck :: Expr a -> (forall ty. Maybe (Expr ty) -> r) -> r

-- | Reinterpret a Solr expression.
reinterpret :: ExprSYM expr => Expr ty -> expr ty
instance Solr.Expr.Class.ExprSYM Solr.Expr.Initial.Typed.Expr


-- | This module defines the finally tagless Solr DSL. This style admits
--   multiple interpreters, two of which (lazy <a>Text</a>s and an initial
--   encoding) are provided by this library, in the <a>Solr.Query</a> and
--   <a>Solr.Query.Initial</a> modules, respectively.
--   
--   Ordinary users should not normally have to import this module.
module Solr.Query.Class

-- | Solr query language.
class ExprSYM expr => QuerySYM expr query

-- | A default field query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] (defaultField (word "foo") :: Query Expr)
--   "q=foo"
--   </pre>
defaultField :: QuerySYM expr query => expr a -> query expr

-- | A field query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" :: Query Expr)
--   "q=foo:bar"
--   </pre>
(=:) :: QuerySYM expr query => Text -> expr a -> query expr

-- | An <tt>AND</tt> query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" &amp;&amp;: "baz" =: word "qux" :: Query Expr)
--   "q=(foo:bar AND baz:qux)"
--   </pre>
(&&:) :: QuerySYM expr query => query expr -> query expr -> query expr

-- | An <tt>OR</tt> query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" ||: "baz" =: word "qux" :: Query Expr)
--   "q=(foo:bar OR baz:qux)"
--   </pre>
(||:) :: QuerySYM expr query => query expr -> query expr -> query expr

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" -: "baz" =: word "qux" :: Query Expr)
--   "q=(foo:bar NOT baz:qux)"
--   </pre>
(-:) :: QuerySYM expr query => query expr -> query expr -> query expr

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] ("foo" =: word "bar" ^=: 3.5 :: Query Expr)
--   "q=foo:bar^=3.5"
--   </pre>
(^=:) :: QuerySYM expr query => query expr -> Float -> query expr

-- | Negate a query.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compile [] (neg ("foo" =: word "bar") :: Query Expr)
--   "q=-foo:bar"
--   </pre>
neg :: QuerySYM expr query => query expr -> query expr

-- | Named version of (<a>=:</a>).
field :: QuerySYM expr query => Text -> expr a -> query expr

-- | Named version of (<a>&amp;&amp;:</a>).
and :: QuerySYM expr query => query expr -> query expr -> query expr
infixr 3 `and`

-- | Named version of (<a>||:</a>).
or :: QuerySYM expr query => query expr -> query expr -> query expr
infixr 2 `or`

-- | Named version of (<a>-:</a>).
not :: QuerySYM expr query => query expr -> query expr -> query expr
infixr 1 `not`

-- | Named version of (<a>^=:</a>).
score :: QuerySYM expr query => query expr -> Float -> query expr
infixr 4 `score`


-- | An initial encoding of a Solr query. This is an alternative
--   interpretation of the Solr language that is more amenable to parsing
--   from arbitrary user input and applying query transformations.
module Solr.Query.Initial

-- | An initial encoding of a Solr query.
data Query (expr :: SolrType -> *)
QDefaultField :: (expr a) -> Query
QField :: Text -> (expr a) -> Query
QAnd :: (Query expr) -> (Query expr) -> Query
QOr :: (Query expr) -> (Query expr) -> Query
QNot :: (Query expr) -> (Query expr) -> Query
QScore :: (Query expr) -> Float -> Query
QNeg :: (Query expr) -> Query
QAppend :: (Query expr) -> (Query expr) -> Query

-- | Type check an untyped Solr query. Note the untyped <a>Expr</a> on the
--   way in is not the same as the typed <a>Expr</a> on the way out.
typeCheck :: Query Expr -> Maybe (Query Expr)

-- | Factor a Solr query into a canonical form (e.g. perform
--   double-negation elimination). Check the source code for all
--   transformations performed.
factor :: Query expr -> Query expr

-- | Reinterpret an initially-encoded <a>Query</a> to some other
--   interpretation.
--   
--   This may be useful for reinterpreting a <a>Query</a> as a lazy
--   <a>Text</a> after it's been type checked and factored with the
--   machinery in this module.
reinterpret :: forall expr query. (QuerySYM expr query, Semigroup (query expr)) => Query Expr -> query expr
instance GHC.Classes.Eq (Solr.Query.Initial.Query Solr.Expr.Initial.Untyped.Expr)
instance Data.Constraint.Forall.ForallF GHC.Show.Show expr => GHC.Show.Show (Solr.Query.Initial.Query expr)
instance Data.Semigroup.Semigroup (Solr.Query.Initial.Query expr)
instance Data.Generics.Uniplate.Operations.Uniplate (Solr.Query.Initial.Query expr)
instance Solr.Expr.Class.ExprSYM expr => Solr.Query.Class.QuerySYM expr Solr.Query.Initial.Query
instance Solr.Param.Internal.HasParamDefaultField Solr.Query.Initial.Query
instance Solr.Param.Internal.HasParamOp Solr.Query.Initial.Query
instance Solr.Param.Internal.HasParamRows Solr.Query.Initial.Query
instance Solr.Param.Internal.HasParamStart Solr.Query.Initial.Query

module Solr.Expr

-- | <pre>
--   <a>Expr</a> :: <a>SolrType</a> -&gt; *
--   </pre>
--   
--   An opaque Solr expression, indexed by its <a>SolrType</a>. Its
--   interpretation, accessed via e.g. <a>compile</a>, is a lazy
--   <a>Text</a>.
--   
--   For an initially-encoded version, see <a>Solr.Expr.Initial.Untyped</a>
--   or <a>Solr.Expr.Initial.Typed</a>.
data Expr (t :: SolrType)

module Solr.FilterQuery

-- | A Solr filter query. This is like <a>Query</a>, but with different
--   local parameters available. All functions polymorphic over
--   <a>QuerySYM</a> will work with both.
data FilterQuery expr

-- | Compile a <a>FilterQuery</a> to a lazy <a>Text</a>.
compile :: [Param FilterQuery] -> FilterQuery expr -> Text
instance Data.Semigroup.Semigroup (Solr.FilterQuery.FilterQuery expr)
instance Solr.Query.Class.QuerySYM Solr.Expr.Internal.Expr Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamCache Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamCost Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamDefaultField Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamOp Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamRows Solr.FilterQuery.FilterQuery
instance Solr.Param.Internal.HasParamStart Solr.FilterQuery.FilterQuery


-- | This is the simplest interpretation of the Solr query language as a
--   lazy <tt>Text</tt>.
--   
--   Not all type-correct expressions using the Solr DSL result in
--   well-formed queries. For example,
--   
--   <pre>
--   &gt;&gt;&gt; let query = (("foo" =: word "bar") ^=: 1.0) ^=: 2.0 :: QuerySYM expr query =&gt; query expr
--   
--   &gt;&gt;&gt; compile [] (query :: Query Expr)
--   "q=foo:bar^=1.0^=2.0"
--   </pre>
--   
--   For this reason, you may want to first interpret a query using
--   <a>Solr.Query.Initial</a>, manually fix up the AST (perhaps with
--   <a>factor</a>), and then reinterpret it as the lazy <tt>Text</tt>
--   version using <a>reinterpret</a>:
--   
--   <pre>
--   &gt;&gt;&gt; import Solr.Query.Initial (factor, reinterpret)
--   
--   &gt;&gt;&gt; compile [] (reinterpret (factor query) :: Query Expr)
--   "q=foo:bar^=2.0"
--   </pre>
module Solr.Query

-- | A Solr query.
data Query (expr :: SolrType -> *)

-- | Compile a <a>Query</a> to a lazy <a>Text</a>.
--   
--   Note that the DSL admits many ways to create an invalid Solr query
--   (e.g. multiple <a>neg</a>s); that is, if it compiles, it doesn't
--   necessarily work.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let query = "foo" =: phrase ["bar", "baz"] ~: 5 &amp;&amp;: defaultField (regex "wh?t") :: Query Expr
--   
--   &gt;&gt;&gt; compile [paramDefaultField "body"] query
--   "q={!df=body}(foo:\"bar baz\"~5 AND /wh?t/)"
--   </pre>
compile :: [Param Query] -> Query expr -> Text
