-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package lucene-query
@version 0.1.0.0

module Lucene.Type

-- | A Lucene type.
data LuceneType
TInt :: LuceneType
TBool :: LuceneType
TWord :: LuceneType
TFuzzyWord :: LuceneType
TBoostedWord :: LuceneType
TWild :: LuceneType
TRegex :: LuceneType
TPhrase :: LuceneType
TFuzzyPhrase :: LuceneType
TBoostedPhrase :: LuceneType
TRange :: LuceneType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class FuzzableType (a :: LuceneType) where type family TFuzzed a :: LuceneType

-- | <pre>
--   type TFuzzed TWord = TFuzzyWord
--   </pre>

-- | <pre>
--   type TFuzzed TPhrase = TFuzzyPhrase
--   </pre>

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class BoostableType (a :: LuceneType) where type family TBoosted a :: LuceneType

-- | <pre>
--   type TBoosted TWord = TBoostedWord
--   </pre>

-- | <pre>
--   type TBoosted TPhrase = TBoostedPhrase
--   </pre>

-- | Types that can appear in a range expression.
class PrimType (a :: LuceneType)
instance Lucene.Type.FuzzableType 'Lucene.Type.TWord
instance Lucene.Type.FuzzableType 'Lucene.Type.TPhrase
instance Lucene.Type.BoostableType 'Lucene.Type.TWord
instance Lucene.Type.BoostableType 'Lucene.Type.TPhrase
instance Lucene.Type.PrimType 'Lucene.Type.TWord
instance Lucene.Type.PrimType 'Lucene.Type.TInt

module Lucene.Class

-- | The finally tagless Lucene class. This admits multiple interpreters,
--   with one (lazy <a>ByteString</a>s) provided by this library, in the
--   <a>Lucene.Query</a> module.
--   
--   For simplicity, the type signatures in the examples below monomorphise
--   the functions to use <a>LuceneQuery</a> (and therefore
--   <a>LuceneExpr</a>, due to the functional dependency).
class Lucene expr query | query -> expr, expr -> query

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
--   
--   Or, with <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although it must not begin with a <tt>'*'</tt>. Must
--   also <i>not</i> contain any spaces or tildes (<tt>'~'</tt>), though
--   this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example (with <tt>OverloadedStrings</tt>):
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt> and <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <tt>LuceneExpr</tt> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <tt>LuceneExpr</tt> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzz</a> (<a>word</a> "bar") 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzz</a> (<a>phrase</a> ["bar", "baz", "qux"]) 10
--   </pre>
fuzz :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>to</a> (<a>incl</a> (<a>int</a> 5)) (<a>excl</a> (<a>int</a> 10))
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | A boost expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   boost :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>boost</a> (<a>word</a> "bar") 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>boost</a> (<a>phrase</a> ["bar", "baz"]) 3.5
--   </pre>
boost :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar -baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Lucene expr query => query -> query -> query

-- | An infix version of <a>fuzz</a>.
(~:) :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   -- equivalent to: "foo" <a>=:</a> <a>fuzz</a> (<a>word</a> "bar") 2
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | An infix version of <a>boost</a>.
(^:) :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a> or <a>excl</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: Lucene expr query => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: Lucene expr query => expr a -> Boundary (expr a)

module Lucene.Query

-- | A Lucene query.
data LuceneQuery

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar -baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Lucene expr query => query -> query -> query

-- | A Lucene expression.
data LuceneExpr (t :: LuceneType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
--   
--   Or, with <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although it must not begin with a <tt>'*'</tt>. Must
--   also <i>not</i> contain any spaces or tildes (<tt>'~'</tt>), though
--   this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example (with <tt>OverloadedStrings</tt>):
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt> and <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <tt>LuceneExpr</tt> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <tt>LuceneExpr</tt> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzz</a> (<a>word</a> "bar") 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzz</a> (<a>phrase</a> ["bar", "baz", "qux"]) 10
--   </pre>
fuzz :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | An infix version of <a>fuzz</a>.
(~:) :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   -- equivalent to: "foo" <a>=:</a> <a>fuzz</a> (<a>word</a> "bar") 2
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>to</a> (<a>incl</a> (<a>int</a> 5)) (<a>excl</a> (<a>int</a> 10))
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | A boost expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   boost :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>boost</a> (<a>word</a> "bar") 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>boost</a> (<a>phrase</a> ["bar", "baz"]) 3.5
--   </pre>
boost :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | An infix version of <a>boost</a>.
(^:) :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>LuceneQuery</a> to a lazy <a>ByteString</a>. Because the
--   underlying expressions are correct by consutruction, this function is
--   total.
compileLuceneQuery :: LuceneQuery -> ByteString
instance GHC.Num.Num (Lucene.Query.LuceneExpr 'Lucene.Type.TInt)
instance Data.String.IsString (Lucene.Query.LuceneExpr 'Lucene.Type.TWord)
instance GHC.Exts.IsList (Lucene.Query.LuceneExpr 'Lucene.Type.TPhrase)
instance Lucene.Class.Lucene Lucene.Query.LuceneExpr Lucene.Query.LuceneQuery
