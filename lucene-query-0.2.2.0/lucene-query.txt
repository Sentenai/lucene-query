-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package lucene-query
@version 0.2.2.0

module Lucene.Type

-- | A Lucene type.
data LuceneType
TInt :: LuceneType
TBool :: LuceneType
TWord :: LuceneType
TFuzzyWord :: LuceneType
TBoostedWord :: LuceneType
TWild :: LuceneType
TRegex :: LuceneType
TPhrase :: LuceneType
TFuzzyPhrase :: LuceneType
TBoostedPhrase :: LuceneType
TRange :: LuceneType

-- | Types that can be fuzzed by a <tt>'~'</tt> operator.
class FuzzableType (a :: LuceneType) where type family TFuzzed a :: LuceneType

-- | <pre>
--   type TFuzzed TWord = TFuzzyWord
--   </pre>

-- | <pre>
--   type TFuzzed TPhrase = TFuzzyPhrase
--   </pre>

-- | Types that can be boosted by a <tt>'^'</tt> operator.
class BoostableType (a :: LuceneType) where type family TBoosted a :: LuceneType

-- | <pre>
--   type TBoosted TWord = TBoostedWord
--   </pre>

-- | <pre>
--   type TBoosted TPhrase = TBoostedPhrase
--   </pre>

-- | Types that can appear in a range expression.
class PrimType (a :: LuceneType)
instance Lucene.Type.FuzzableType 'Lucene.Type.TWord
instance Lucene.Type.FuzzableType 'Lucene.Type.TPhrase
instance Lucene.Type.BoostableType 'Lucene.Type.TWord
instance Lucene.Type.BoostableType 'Lucene.Type.TPhrase
instance Lucene.Type.PrimType 'Lucene.Type.TWord
instance Lucene.Type.PrimType 'Lucene.Type.TInt


-- | This module defines the Lucene DSL. Ordinary users should instead
--   import either <a>Lucene.Query</a> or <a>Lucene.Query.Qualified</a>.
module Lucene.Class

-- | The finally tagless Lucene class. This admits multiple interpreters,
--   with one (lazy <a>ByteString</a>s) provided by this library, in the
--   <a>Lucene.Query</a> module.
--   
--   For simplicity, the type signatures in the examples below monomorphise
--   the functions to use <a>LuceneQuery</a> (and therefore
--   <a>LuceneExpr</a>, due to the functional dependency).
class Lucene expr query | query -> expr, expr -> query

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Lucene expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Lucene query (I haven't
--   tested), but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: Lucene expr query => query -> Float -> query

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: Lucene expr query => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: Lucene expr query => expr a -> Boundary (expr a)
star :: Lucene expr query => Boundary (expr a)


-- | This module is an alternative to <a>Lucene.Class</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Lucene.Class.Qualified as Lucene
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<tt>~:</tt>)  = <a>fuzz</a>
--   (<tt>^:</tt>)  = <a>boost</a>
--   (<tt>=:</tt>)  = <a>field</a>
--   (<tt>&amp;&amp;:</tt>) = <a>and</a>
--   (<tt>||:</tt>) = <a>or</a>
--   (<tt>-:</tt>)  = <a>not</a>
--   (<tt>^=:</tt>) = <a>score</a>
--   </pre>
module Lucene.Class.Qualified

-- | The finally tagless Lucene class. This admits multiple interpreters,
--   with one (lazy <a>ByteString</a>s) provided by this library, in the
--   <a>Lucene.Query</a> module.
--   
--   For simplicity, the type signatures in the examples below monomorphise
--   the functions to use <a>LuceneQuery</a> (and therefore
--   <a>LuceneExpr</a>, due to the functional dependency).
class Lucene expr query | query -> expr, expr -> query

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>int</a> 5)
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" Lucene.<a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" Lucene.<a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" ("bar" :: Lucene.<a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>wild</a> "b?r")
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>regex</a> "[mb]oat")
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", Lucene.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (["bar", "baz"] :: Lucene.<a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzz</a> (Lucene.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzz</a> (Lucene.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>incl</a> (Lucene.<a>int</a> 5) `Lucene.to` Lucene.<a>excl</a> (Lucene.<a>int</a> 10))
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   boost :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>boost</a> (Lucene.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>boost</a> (Lucene.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")
--   </pre>
field :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.and` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
and :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.or` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
or :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.not` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
not :: Lucene expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Lucene query (I haven't
--   tested), but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>score</a> (Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")) 3.5
--   </pre>
score :: Lucene expr query => query -> Float -> query

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>gt</a> (Lucene.<a>int</a> 5))
--   </pre>
gt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>gte</a> (Lucene.<a>int</a> 5))
--   </pre>
gte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>lt</a> (Lucene.<a>int</a> 5))
--   </pre>
lt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>lte</a> (Lucene.<a>int</a> 5))
--   </pre>
lte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | An inclusive or exclusive expression for use in a range query, built
--   with either <a>incl</a>, <a>excl</a>, or <a>star</a>.
--   
--   The constructors are exported for use in interpreters.
data Boundary a
Inclusive :: a -> Boundary a
Exclusive :: a -> Boundary a
Star :: Boundary a

-- | Mark an expression as inclusive, for use in a range query.
incl :: Lucene expr query => expr a -> Boundary (expr a)

-- | Mark an expression as exclusive, for use in a range query.
excl :: Lucene expr query => expr a -> Boundary (expr a)
star :: Lucene expr query => Boundary (expr a)


-- | Lucene query construction and compilation. You may prefer to import
--   <a>Lucene.Query.Qualified</a> instead, which does not contain any
--   operators.
module Lucene.Query

-- | A Lucene query.
data LuceneQuery

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   </pre>
(=:) :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>&amp;&amp;:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(&&:) :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--       <a>||:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(||:) :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt>, or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--        <a>-:</a> "baz" <a>=:</a> <a>word</a> "qux"
--   </pre>
(-:) :: Lucene expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Lucene query (I haven't
--   tested), but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^=:</a> 3.5
--   </pre>
(^=:) :: Lucene expr query => query -> Float -> query

-- | A Lucene expression.
data LuceneExpr (t :: LuceneType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>int</a> 5
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar"
--   
--   -- foo:bar
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> ("bar" :: <a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>wild</a> "b?r"
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>regex</a> "[mb]oat"
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", <a>wild</a> "b?z"] -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "b?z"] -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> (["bar", "baz"] :: <a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (~:) :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   (~:) :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>~:</a> 1
--   
--   -- foo:"bar baz qux"~10
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz", "qux"] <a>~:</a> 10
--   </pre>
(~:) :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <tt>fuzz</tt> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>fuzzy</a> "bar"
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>incl</a> (<a>int</a> 5) `to` <a>excl</a> (<a>int</a> 10)
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>gt</a> (<a>int</a> 5)
--   </pre>
gt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>gte</a> (<a>int</a> 5)
--   </pre>
gte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>lt</a> (<a>int</a> 5)
--   </pre>
lt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>lte</a> (<a>int</a> 5)
--   </pre>
lte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   (^:) :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   (^:) :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>word</a> "bar" <a>^:</a> 3.5
--   
--   -- foo:"bar baz"^3.5
--   query :: <a>LuceneQuery</a>
--   query = "foo" <a>=:</a> <a>phrase</a> ["bar", "baz"] <a>^:</a> 3.5
--   </pre>
(^:) :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>LuceneQuery</a> to a lazy <a>ByteString</a>. Because the
--   underlying expressions are correct by consutruction, this function is
--   total.
compileLuceneQuery :: LuceneQuery -> ByteString
instance GHC.Num.Num (Lucene.Query.LuceneExpr 'Lucene.Type.TInt)
instance Data.String.IsString (Lucene.Query.LuceneExpr 'Lucene.Type.TWord)
instance GHC.Exts.IsList (Lucene.Query.LuceneExpr 'Lucene.Type.TPhrase)
instance Lucene.Class.Lucene Lucene.Query.LuceneExpr Lucene.Query.LuceneQuery


-- | This module is an alternative to <a>Lucene.Query</a> that does not
--   export any operators, and is intended to be imported qualified,
--   because it contains function names that clash with the Prelude.
--   
--   <pre>
--   import qualified Lucene.Query.Qualified as Lucene
--   </pre>
--   
--   Here is a quick conversion guide:
--   
--   <pre>
--   (<tt>~:</tt>)  = <a>fuzz</a>
--   (<tt>^:</tt>)  = <a>boost</a>
--   (<tt>=:</tt>)  = <a>field</a>
--   (<tt>&amp;&amp;:</tt>) = <a>and</a>
--   (<tt>||:</tt>) = <a>or</a>
--   (<tt>-:</tt>)  = <a>not</a>
--   (<tt>^=:</tt>) = <a>score</a>
--   </pre>
module Lucene.Query.Qualified

-- | A Lucene query.
data LuceneQuery

-- | A field query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")
--   </pre>
field :: Lucene expr query => Text -> expr a -> query

-- | An <tt>AND</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar AND baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.and` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
and :: Lucene expr query => query -> query -> query

-- | An <tt>OR</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar OR baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.or` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
or :: Lucene expr query => query -> query -> query

-- | A <tt>NOT</tt>, <tt>'!'</tt> or <tt>'-'</tt> query.
--   
--   Example:
--   
--   <pre>
--   -- foo:bar NOT baz:qux
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar") `Lucene.not` Lucene.<a>field</a> "baz" (Lucene.<a>word</a> "qux")
--   </pre>
not :: Lucene expr query => query -> query -> query

-- | The <tt>'^='</tt> constant score operator.
--   
--   This is given right-fixity to reject queries like <tt>q ^= 1 ^=
--   2</tt>, which may very well be a valid Lucene query (I haven't
--   tested), but are nonetheless nonsense.
--   
--   Example:
--   
--   <pre>
--   -- (foo:bar)^=3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>score</a> (Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")) 3.5
--   </pre>
score :: Lucene expr query => query -> Float -> query

-- | A Lucene expression.
data LuceneExpr (t :: LuceneType)

-- | An <tt>int</tt> expression.
--   
--   Note that sometimes you may use the <a>Num</a> instance for
--   <a>LuceneExpr</a> <a>TInt</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>int</a> 5)
--   </pre>
int :: Lucene expr query => Int -> expr TInt

-- | A <tt>true</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:true
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" Lucene.<a>true</a>
--   </pre>
true :: Lucene expr query => expr TBool

-- | A <tt>false</tt> expression.
--   
--   Example:
--   
--   <pre>
--   -- foo:false
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" Lucene.<a>false</a>
--   </pre>
false :: Lucene expr query => expr TBool

-- | A single word. Must <i>not</i> contain any spaces, wildcard characters
--   (<tt>'?'</tt> and <tt>'*'</tt>), or tildes (<tt>'~'</tt>), though this
--   is not enforced by the type system.
--   
--   Note that sometimes you may use the <a>IsString</a> instance for
--   <a>LuceneExpr</a> <a>TWord</a>, but usually an explicit type signature
--   will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>word</a> "bar")
--   
--   -- foo:bar
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" ("bar" :: Lucene.<a>LuceneExpr</a> <a>TWord</a>)
--   </pre>
word :: Lucene expr query => Text -> expr TWord

-- | A single word that may contain wildcard characters (<tt>'?'</tt> and
--   <tt>'*'</tt>), although the meaning of consecutive <tt>'*'</tt>s is
--   probably ill-defined. Must also <i>not</i> contain any spaces or
--   tildes (<tt>'~'</tt>), though this is not enforced by the type system.
--   
--   Example:
--   
--   <pre>
--   -- foo:b?r
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>wild</a> "b?r")
--   </pre>
wild :: Lucene expr query => Text -> expr TWild

-- | A regular expression, whose syntax is described by
--   <a>http://lucene.apache.org/core/5_5_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true</a>.
--   
--   Note that the leading and trailing <tt>'/'</tt> must be omitted. The
--   regex innards are not type checked in any way.
--   
--   <pre>
--   -- foo:/[mb]oat/
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>regex</a> "[mb]oat")
--   </pre>
regex :: Lucene expr query => Text -> expr TRegex

-- | A phrase, composed of multiple (non-fuzzy) words, none of which may
--   contain wildcard characters. Both of these properties are enforced by
--   the type system, as long as the words themselves adhere to the
--   <a>word</a> contract. The list should not be empty.
--   
--   Note that sometimes you may use the <a>IsList</a> instance for
--   <a>LuceneExpr</a> <a>TPhrase</a>, but usually an explicit type
--   signature will be required (at the interpretation site or earlier).
--   
--   Example:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", "baz"]) -- ok
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", Lucene.<a>wild</a> "b?z"]) -- type error
--   
--   -- foo:"bar b?z" (an invalid Lucene query)
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>phrase</a> ["bar", "b?z"]) -- breaks <a>word</a> contract
--   </pre>
--   
--   Or, with <tt>OverloadedLists</tt>:
--   
--   <pre>
--   -- foo:"bar baz"
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (["bar", "baz"] :: Lucene.<a>LuceneExpr</a> <a>TPhrase</a>)
--   </pre>
phrase :: Lucene expr query => [expr TWord] -> expr TPhrase

-- | The <tt>'~'</tt> operator, which fuzzes its argument (either a word or
--   phrase) by a numeric amount.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   fuzz :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyWord</a>   -- Int must be 0, 1, or 2
--   fuzz :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Int -&gt; <a>LuceneExpr</a> <a>TFuzzyPhrase</a> -- Int must be positive
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~1
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzz</a> (Lucene.<a>word</a> "bar") 1)
--   
--   -- foo:"bar baz qux"~10
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzz</a> (Lucene.<a>phrase</a> ["bar", "baz", "qux"]) 10)
--   </pre>
fuzz :: (Lucene expr query, FuzzableType a) => expr a -> Int -> expr (TFuzzed a)

-- | Short-hand for fuzzing a word by 2. This is the default behavior of a
--   Lucene <tt>'~'</tt> operator without an integer added.
--   
--   <pre>
--   <a>fuzzy</a> e = <a>fuzz</a> e 2
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar~
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>fuzzy</a> "bar")
--   </pre>
fuzzy :: Lucene expr query => expr TWord -> expr TFuzzyWord

-- | A range expression.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TWord</a>) -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   to :: <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>Boundary</a> (<a>LuceneExpr</a> <a>TInt</a>)  -&gt; <a>LuceneExpr</a> <a>TRange</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:[5 TO 10}
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>incl</a> (Lucene.<a>int</a> 5) `Lucene.to` Lucene.<a>excl</a> (Lucene.<a>int</a> 10))
--   </pre>
to :: (Lucene expr query, PrimType a) => Boundary (expr a) -> Boundary (expr a) -> expr TRange

-- | Short-hand for a greater-than range query.
--   
--   <pre>
--   <a>gt</a> e = <a>excl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;5
--   -- foo:{5 TO *]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>gt</a> (Lucene.<a>int</a> 5))
--   </pre>
gt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a greater-than-or-equal-to range query.
--   
--   <pre>
--   <a>gte</a> e = <a>incl</a> e `to` <a>star</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&gt;=5
--   -- foo:[5 TO *]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>gte</a> (Lucene.<a>int</a> 5))
--   </pre>
gte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than range query.
--   
--   <pre>
--   <a>lt</a> e = <a>star</a> `to` <a>excl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;5
--   -- foo:[* TO 5}
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>lt</a> (Lucene.<a>int</a> 5))
--   </pre>
lt :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | Short-hand for a less-than-or-equal-to range query.
--   
--   <pre>
--   <a>lte</a> e = <a>star</a> `to` <a>incl</a> e
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:&lt;=5
--   -- foo:[* TO 5]
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>lte</a> (Lucene.<a>int</a> 5))
--   </pre>
lte :: (Lucene expr query, PrimType a) => expr a -> expr TRange

-- | The <tt>'^'</tt> operator, which boosts its argument.
--   
--   This will have one of the following two types:
--   
--   <pre>
--   boost :: <a>LuceneExpr</a> <a>TWord</a>   -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedWord</a>
--   boost :: <a>LuceneExpr</a> <a>TPhrase</a> -&gt; Float -&gt; <a>LuceneExpr</a> <a>TBoostedPhrase</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   -- foo:bar^3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>boost</a> (Lucene.<a>word</a> "bar") 3.5)
--   
--   -- foo:"bar baz"^3.5
--   query :: Lucene.<a>LuceneQuery</a>
--   query = Lucene.<a>field</a> "foo" (Lucene.<a>boost</a> (Lucene.<a>phrase</a> ["bar", "baz"]) 3.5)
--   </pre>
boost :: (Lucene expr query, BoostableType a) => expr a -> Float -> expr (TBoosted a)

-- | Compile a <a>LuceneQuery</a> to a lazy <a>ByteString</a>. Because the
--   underlying expressions are correct by consutruction, this function is
--   total.
compileLuceneQuery :: LuceneQuery -> ByteString
